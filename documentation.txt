Udemy NextJS & Open AI Course John Smilga


Section 01: Next.js Tutorial

01. Course Resources

02. Discord Channel

03. Introduction to Next.js
-otvorimo web stranicu: https://nextjs.org/

04. Tutorial Overview

05. Update !!!
-instalirati verziju 14 Next.js

06. Create New Next.js App
-u terminalu ukucamo komandu npx create-next-app@14 nextjs-tutorial

07. Files and Folder Structure
-u nextjs-tutorial/README.md fajl dodan opis izrade projekta

08. Home Page
-u app/page.js komponenti kreiramo i eksportujemo kao default funkciju HomePage()

09. More Pages
-u folderu app kreiramo folder about i komponentu page.js
-u about/page.js komponenti kreiramo i eksportujemo kao default funkciju AboutPage()
-otvorimo rutu http://localhost:3000/about

10. Link Component
-otvorimo link: https://nextjs.org/docs/pages/api-reference/components/link
-u komponentu app/page.js importujemo komponentu Link
-u roditelj div element dodajemo komponentu Link sa otvorenim i zatvorenim tagom
-komponenti Link dodajemo prop href i className
-ponovimo isti postupak u komponenti about/page.js

11. Nested Routes
-u folderu about kreiramo folder info i komponentu page.js

Quiz 1: Fundamentals Quiz

12. First Challenge
-u folderu app kreiramo folder client, drinks, prisma-example, query i tasks
-u svakom folderu kreiramo komponente page.js

13. CSS
-otvorimo web stranicu: https://daisyui.com/
-otvorimo web stranicu: https://tailwindcss.com/
-otvorimo link: https://www.npmjs.com/package/daisyui
-otvorimo link: https://www.npmjs.com/package/@tailwindcss/typography
-u terminalu instaliramo pakete Daisy UI i Tailwind CSS Typography
-u terminalu ukucamo komande: npm i -D daisyui@3.9.4 i npm i @tailwindcss/typography

14. TailwindCSS

15. DaisyUI

16. Layout File
-u komponenti layout.js, promjenjen opis projekta u varijabli const metadata
-u jsx-u kreiran nav element 

17. Navbar Challenge
-kreiramo folder components i komponentu Navbar.jsx
-u komponentu Navbar.jsx importujemo komponentu Link
-kreiramo varijablu niz links
-kreiramo i eksportujemo funkciju Navbar() kao default
-u jsx-u kreiramo nav element sa Tailwind CSS klasama
-u nav elementu kreiramo div element sa Tailwind CSS klasama
-u div element dodajemo komponentu Link sa prop href i className
-kreiramo ul element sa Tailwind CSS klasama
-u ul element dodajemo metodu links?.map()
-u funkciji map(), u return izjavi kreiramo li element
-u li element dodajemo komponentu Link sa prop href i className
-u komponentu layout.js importujemo komponentu Navbar.jsx
-u jsx-u, u body element dodajemo komponentu Navbar
-kreiramo main element sa Tailwind CSS klasama
-u main elementu dinamicki prikazujemo prop children

18. Server Component vs Client Component
-otvorimo link: https://nextjs.org/docs/app/building-your-application/rendering/server-components
-otvorimo link: https://nextjs.org/docs/app/building-your-application/rendering/client-components

19. Counter Challenge
-u komponenti app/page.js, HTML elementima dodajemo Tailwind CSS klase
-u komponentu client/page.js importujemo funkciju useState iz paketa React
-kreiramo state varijablu const count i set funkciju setCount
-u jsx-u kreiramo button element sa Daisy UI klasama
-button elementu dodajemo dogadaj onClick
-u dogadaj onClick dodajemo anonimnu funkciju
-u anonimnu funkciju proslijedujemo funkciju setCount()
-dodajemo direktivu 'use client'

20. Fetch data
-u komponenti drinks/page.js, funkciji DrinksPage() dodajemo asinhronost
-kreiramo varijablu const url
-u funkciji DrinksPage() dodajemo metodu await fetch(url)
-vrijednost metode await fetch(url) pohranjujemo u varijablu const response
-dodajemo metodu await response.json()
-vrijednost metode await response.json() pohranjujemo u varijablu const data

21. Loading Component
-u komponenti drinks/page.js kreiramo funkciju fetchDrinks()
-u funkciju fetchDrinks() dodajemo metodu await new Promise() i varijable const response i const data
-dodajemo izjavu return data
-u funkciju DrinksPage() dodajemo funkciju await fetchDrinks()
-vrijednost funkcije await fetchDrinks() pohranjujemo u varijablu const drinks
-kreiramo loading.js fajl
-u loading.js fajlu kreiramo i eksportujemo funkciju loading() kao default

22. Error Component
-u folderu drinks kreiramo error.js fajl
-u error.js fajlu kreiramo i eksportujemo funkciju error() kao default
-u komponenti drinks/page.js, u funkciju fetchDrinks() dodajemo uslov if (!response.ok)

23. Nested Layouts
-u folderu drinks kreiramo layout.js fajl
-u layout.js fajlu kreiramo i eksportujemo funkciju DrinksLayout()
-funkciji DrinksLayout() dodajemo parametar destruktuirani prop children
-u jsx-u kreiramo HTML elemente sa Tailwind CSS klasama
-u roditelj div element dinamicki prikazujemo vrijednost prop children

24. Dynamic Routes
-u folderu drinks kreiramo folder [id] i komponentu page.js
-u [id]/page.js fajlu kreiramo i eksportujemo funkciju SingleDrinkPage() kao default
-funkciji SingleDrinkPage() dodajemo parametar destruktuirani prop params

25. Drinks List - Challenge
-u folderu components kreiramo komponentu DrinksList.jsx
-funkciji DrinksList() dodajemo parametar destruktuirani prop drinks
-u komponentu drinks/page.js importujemo komponentu DrinksList.jsx
-u jsx-u dodajemo komponentu DrinksList sa prop drinks
-u komponenti DrinksList.jsx, u jsx-u kreiramo ul element kao roditelj element sa Tailwind CSS klasama
-u ul element dodajemo metodu drinks.map()
-u funkciji map() kreiramo li element sa prop key
-importujemo komponentu Link
-u li element dodajemo komponentu Link sa prop href
-u prop href dodajemo dinamicki link

26. Single Drink - Challenge
-u komponenti [id]/page.js kreiramo varijablu const url
-importujemo komponentu Link
-kreiramo asinhronu funkciju getSingleDrink() sa parametrom id
-u funkciji getSingleDrink() kreiramo varijablu const res
-dodajemo uslov if (!res.ok)
-u uslov if dodajemo funkciju throw new Error()
-funkciji SingleDrinkPage() dodajemo asinhronost
-u funkciji SingleDrinkPage() kreiramo varijablu const data
-kreiramo varijable const title i const imgSrc
-u jsx-u, u roditelj div element dodajemo komponentu Link sa prop href i className

27. Static Images
-u komponentu [id]/page.js importujemo sliku drinkImg
-preuzmemo sliku
-kreiramo folder public
-preuzetu sliku pohranjujemo u folder public
-otvorimo link: https://nextjs.org/docs/pages/api-reference/components/image
-importujemo komponentu Image iz paketa Next Image
-u jsx-u dodajemo komponentu Image sa prop src, alt i className

28. Remote Images
-u komponenti [id]/page.js dodajemo komponentu Image sa prop src, alt, width, height, className i priority
-otvorimo link: https://stackoverflow.com/questions/76164057/next-js-hostname-not-configured-under-images-in-next-config-js-even-though-remot
-u next.config.mjs fajl dodajemo objekt images i niz remotePatterns

29. Responsive Images
-u komponentu DrinksList.jsx importujemo komponentu Image
-u jsx-u ul elementu dodajemo Tailwind CSS Grid klase
-u jsx-u, u komponenti Link kreiramo div element sa Tailwind CSS klasu
-u div element dodajemo komponentu Image
-komponenti Image dodajemo prop src, alt, className, sizes i fill

30. More Routing
-u folderu app kreiramo folder _css i styles.css fajl
-kreiramo foldere (dashboard), auth i komponentu page.js
-u folderu auth kreiramo folder [[...sign-in]] i komponentu route.js
-u pretrazivacu otvorimo rutu: http://localhost:3000/auth

31. Prisma Setup
-otvorimo web stranicu: https://www.prisma.io/
-otvorimo link: https://www.npmjs.com/package/prisma
-otvorimo link: https://www.npmjs.com/package/@prisma/client
-u terminalu instaliramo pakete Prisma i Prisma Client
-u terminalu ukucamo komande npm install prisma --save-dev i npm install @prisma/client
-u terminalu ukucamo komandu npx prisma init
-generisemo folder prisma i schema.prisma fajl
-u .gitignore fajl dodajemo .env fajl
-otvorimo link: https://www.prisma.io/docs/getting-started/quickstart-sqlite
-u .env fajl dodajemo u varijablu: DATABASE_URL="file:./dev.db"
-u schema.prisma fajl dodajemo u objekt datasource db key - value par provider = "sqlite"
-otvorimo link: https://www.prisma.io/docs/guides/other/troubleshooting-orm/help-articles/nextjs-prisma-client-dev-practices#solution
-kreiramo folder utils i db.ts fajl
-u db.ts fajl kopiramo kod iz dokumentacije

32. Prisma Model
-u schema.prisma fajlu kreiramo model Task
-u terminalu ukucamo komandu npx prisma migrate dev 
-odaberemo ime task model
-generisemo folder migrations i fajlove unutar njega
-u terminalu ukucamo komandu npx prisma studio

33. Prisma CRUD
-otvorimo link: https://www.prisma.io/docs/concepts/components/prisma-client/crud
-u komponentu prisma-example importujemo instancu prisma iz foldera utils
-kreiramo asinhronu funkciju prismaHandlers()
-u funkciju prismaHandlers() dodajemo metodu await prisma.task.create()
-u funkciju create() dodajemo konfiguracioni objekt
-u konfiguracioni objekt dodajemo objekt data
-dodajemo metodu await prisma.task.findMany()
-vrijednost metode await prisma.task.findMany() pohranjujemo u varijablu const allTasks
-u funkciju createMany() dodajemo konfiguracioni objekt
-u konfiguracioni objekt dodajemo objekt orderBy
-u funkciju prismaHandlers() dodajemo metodu return allTasks
-funkciji PrismaExamplePage() dodajemo asinhronost
-u funkciju PrismaExamplePage() dodajemo funkciju await prismaHandlers()
-vrijednost funkcije await prismaHandlers() pohranjujemo u varijablu const tasks
-u jsx-u, u div element dodajemo metodu tasks?.map()
-u funkciji map() kreiramo h2 element sa prop key i className

34. Display Tasks - Challenge
-u folderu components kreiramo tri jsx komponente: TaskForm, TaskList i DeleteForm
-u komponentu tasks/page.js importujemo komponente TaskForm.jsx i TaskList.jsx
-u komponenti TaskList.jsx, funkciji TaskList() dodajemo asinhronost
-u funkciju TaskList() dodajemo metodu await.prisma.task.findMany()
-vrijednost metode await.prisma.task.findMany() pohranjujemo u varijablu const tasks
-u funkciju findMany() dodajemo konfiguracioni objekt
-u konfiguracioni objekt dodajemo objekt orderBy
-dodajemo uslov (tasks.length === 0) i h2 element sa Tailwind CSS klasama
-importujemo instancu prisma i komponentu Link
-u jsx-u kreiramo ul element
-u ul element dodajemo metodu tasks?.map()
-u funkciji map() kreiramo li element sa prop key i className
-u li elementu kreiramo element h2 i div
-h2 elementu dodajemo prop className i dinamicke klasu
-u div element dodajemo komponentu Link sa prop href i className
-importujemo komponentu DeleteForm.jsx
-u div element dodajemo komponentu DeleteForm sa prop id

35. Server Actions - Info

36. First Server Action
-u komponenti TaskForm.jsx, u jsx-u kreiramo form element kao roditelj element
-importujemo instancu prisma
-u form elementu kreiramo div element sa Tailwind CSS klasama
-u div elementu kreiramo elemente input i button sa Tailwind CSS klasama
-input elementu dodajemo prop type, className, placeholder, name i required
-button elementu dodajemo prop type i className
-funkciji TaskForm() dodajemo asinhronost
-kreiramo asinhronost funkciju createTask()
-form elementu dodajemo prop action
-u prop action proslijedujemo funkciju createTask
-funkciji createTask() dodajemo parametar formData
-u funkciju createTask dodajemo direktivu 'use server'
-dodajemo metodu formData.get()
-vrijednost metode formData.get() pohranjujemo u varijablu const content
-dodajemo metodu await prisma.task.create()
-u funkciju create() dodajemo konfiguracioni objekt
-u konfiguracioni objekt dodajemo objekt data
-importujemo funkciju revalidatePath iz paketa Next Cache
-otvorimo link: https://nextjs.org/docs/app/api-reference/functions/revalidatePath
-u funkciju createTask() dodajemo funkciju revalidatePath('/tasks')

37. Refactor App
-u folderu utils kreiramo actions.js fajl
-u actions.js fajl dodajemo direktivu 'use server'
-importujemo funkciju revalidatePath i instancu prisma
-u actions.js fajl premjestamo funkciju createTask()
-kreiramo asinhronu funkciju getAllTasks()
-u funkciju getAllTasks() dodajemo izjavu return prisma.task.findMany()
-u komponentu TaskList.jsx importujemo funkciju getAllTasks() iz actions.js fajla
-vrijednost funkcije await getAllTasks() pohranjujemo u varijablu const tasks
-u komponentu TaskForm.jsx importujemo funkcije createTask iz actions.js fajla

38. Delete Task
-u actions.js fajlu kreiramo i eksportujemo asinhronu funkciju deleteTask()
-funkciji deleteTask() dodajemo parametar formData
-u funkciji deleteTask() kreiramo varijablu const id
-dodajemo metodu await prisma.task.delete()
-dodajemo funkciju revalidatePath('/tasks')
-u komponentu DeleteForm.jsx importujemo funkciju deleteTask iz foldera utils
-u jsx-u kreiramo form element kao roditelj element
-funkciji DeleteForm() dodajemo parametar destruktuirani prop id
-form elementu dodajemo prop action
-u prop action proslijedujemo funkciju deleteTask
-u form elementu kreiramo input element sa prop type, name i value
-kreiramo button element sa prop className

39. Edit Task - Setup
-u actions.js fajlu kreiramo i eksportujemo asinhrone funkcije getTask() i editTask()
-funkciji getTask() dodajemo parametar id
-funkciji editTask() dodajemo parametar formData
-u folderu components kreiramo komponentu EditForm.jsx
-u folderu tasks kreiramo folder [id] i komponentu page.js
-u komponenti [id]/page.js kreiramo funkciju EditTaskPage()
-funkciji EditTaskPage() dodajemo parametar destruktuirani prop params
-funkciji EditTaskPage() dodajemo asinhronost
-importujemo funkciju getTask() iz foldera utils
-u funkciju EditTaskPage() dodajemo funkciju await getTask(params.id)
-vrijednost funkcije await getTask(params.id) pohranjujemo u varijablu const task
-u actions.js fajlu, u funkciju getTask() dodajemo metodu return prisma.task.findUnique()
-u funkciju findUnique() dodajemo konfiguracioni objekt
-u konfiguracioni objekt dodajemo objekt where
-u komponenti [id]/page.js, roditelj div elementu dodajemo prop className
-importujemo komponente Link i EditForm.jsx
-u roditelj div element dodajemo komponentu Link 
-komponenti Link dodajemo prop href i className
-ispod komponente Link dodajemo komponentu EditForm sa prop task

40. Edit Task - Complete
-u komponenti EditForm.jsx destruktuiramo varijable const { id, completed, content }
-dodajemo direktivu 'use client'
-u jsx-u kreiramo form element kao roditelj element
-form elementu dodajemo prop action i className
-importujemo funkciju editTask iz foldera utils
-u prop action proslijedujemo funkciju editTask
-u form elementu kreiramo input element sa prop type, name i value
-kreiramo jos jedan input element sa prop type, required, defaultValue, name i className
-kreiramo div element sa Daisy UI klasama
-u div elementu kreiramo elemente label, span i input
-input elementu dodajemo prop type, defaultChecked, id, name i className
-kreiramo button element sa Daisy UI klasama
-u actions.js fajlu kreiramo varijable const id, const content i const completed
-dodajemo metodu await prisma.task.update()
-u funkciju update() dodajemo konfiguracioni objekt
-u konfiguracioni objekt dodajemo objekte where i data
-otvorimo link: https://nextjs.org/docs/app/api-reference/functions/redirect
-importujemo funkciju redirect iz paketa Next Navigation
-u funkciju editTask() dodajemo funkciju redirect('/tasks')

41. Pending State
-otvorimo link: https://react.dev/reference/react-dom/hooks/useFormStatus
-u actions.js fajlu kreiramo i eksportujemo asinhronu funkciju createTaskCustom()
-u funkciju createTaskCustom() dodajemo metodu await new Promise()
-kreiramo komponentu TaskFormCustom.jsx
-u komponentu tasks/page.js importujemo komponentu TaskFormCustom.jsx
-u komponentu TaskFormCustom.jsx importujemo funkciju createTaskCustom iz foldera utils
-dodajemo direktivu 'use client'
-importujemo funkciju useFormStatus iz paketa React Dom
-kreiramo funkciju SubmitButton()
-u funkciju SubmitButton() dodajemo funkciju useFormStatus()
-vrijednost funkcije useFormStatus() pohranjujemo u destruktuiranu varijablu const { pending }
-u jsx-u premjestamo button elemente iz funkcije TaskFormCustom()
-button elementu dodajemo prop disabled
-u prop disabled proslijedujemo varijablu pending
-u button elementu dodajemo ternarni uslov za varijablu pending
-u funkciju TaskFormCustom() dodajemo komponentu SubmitButton

42. Error Checking
-u actions.js fajlu, u funkciju createTaskCustom() dodajemo blokove koda try - catch
-funkciji createTaskCustom() dodajemo parametar prevState
-u blok koda try dodajemo metodu awat prisma.task.create() i revalidatePath()
-dodajemo izjavu return objekt poruku
-u blok koda catch dodajemo izjavu return objekt poruku
-u komponentu TaskFormCustom.jsx importujemo funkciju useFormState iz paketa React Dom
-kreiramo varijablu const initialState
-u funkciji TaskFormCustom() dodajemo funkciju useFormState(createTaskCustom, initialState)
-vrijednost funkcije useFormState() pohranjujemo u varijable const [state, formAction]
-u prop action proslijedujemo funkciju formAction
-u form elementu dodajemo ternarni uslov state.message
-prvi dio ternarnog uslova je p element, a drugi dio ternarnog uslova je vrijednost null

43. Zod Library
-otvorimo web stranicu: https://zod.dev/
-otvorimo link: https://www.npmjs.com/package/zod
-u terminalu instaliramo paket Zod sa komandom npm i zod
-u actions.js fajlu importujemo instancu z iz paketa Zod
-u funkciji createTaskCustom() dodajemo metodu z.object()
-vrijednost metode z.object() pohranjujemo u varijablu const Task
-u blok koda try dodajemo metodu Task.parse()

44. Providers
-otvorimo link: https://www.npmjs.com/package/react-hot-toast
-u terminalu instaliramo paket React Hot Toast sa komandom npm i react-hot-toast
-u folderu app kreiramo providers.js fajl
-u providers.js fajlu kreiramo i eksportujemo funkciju Providers() kao default
-funkciji Providers() dodajemo parametar destruktuirani prop children
-dodajemo direktivu 'use client'
-importujemo komponentu Toaster iz paketa React Hot Toaster
-u jsx-u dodajemo prazan fragment kao roditelj element
-u komponentu layout.js importujemo komponentu Providers
-u main element dodajemo komponentu Providers sa otvorenim i zatvorenim tagom
-u komponentu TaskFormCustom.jsx importujemo funkcije useEffect i toast
-u funkciju TaskFormCustom() dodajemo funkciju useEffect()
-u funkciju useEffect() dodajemo dva uslova if

45. Delete Button - Challenge
-u komponentu DeleteForm.jsx dodajemo direktivu 'use client'
-importujemo funkciju useFormStatus iz paketa React Dom
-kreiramo funkciju SubmitButton()
-u funkciju SubmitButton() dodajemo funkciji useFormStatus()
-vrijednost funkcije useFormStatus() pohranjujemo u destruktuiranu varijablu const { pending }
-u jsx-u kreiramo button element sa Daisy UI klasama
-button elementu dodajemo prop disabled
-u prop disabled proslijedujemo vrijednost varijable pending
-u button element dodajemo ternarni operator za varijablu pending
-u funkciju DeleteForm() dodajemo komponentu SubmitButton 

46. Route Handlers - Info
-otvorimo link: https://nextjs.org/docs/app/building-your-application/routing/route-handlers
-otvorimo aplikaciju Postman

47. Route Handlers - GET
-u folderu app kreiramo foldere api, tasks i route.js fajl
-u tasks/route.js fajl importujemo instancu db iz foldera utils
-kreiramo i eksportujemo asinhronu funkciju GET() sa parametrom request
-u funkciju GET() dodajemo metodu await db.task.findMany()
-vrijednost metode await db.task.findMany() pohranjujemo u varijablu const tasks
-dodajemo izjavu return Response.json()
-u pretrazivacu otvorimo rutu: http://localhost:3000/api/tasks

48. Route Handlers - POST
-u posts/route.js fajlu kreiramo i eksportujemo asinhronu funkciju POST() sa parametrom request
-u funkciju POST() dodajemo metodu await request.json()
-vrijednost metode await request.json() pohranjujemo u varijablu const data
-dodajemo metodu await db.task.create()
-u funkciju createTask() dodajemo konfiguracioni objekt
-u konfiguracioni objekt dodajemo objekt data
-vrijednost metode await db.task.create() pohranjujemo u varijablu const task
-dodajemo izjavu Response.json()
-importujemo funkciju NextResponse iz paketa Next Server
-u funkcije GET() i POST() dodajemo funkciju NextResponse()

49. Middleware
-otvorimo link: https://nextjs.org/docs/app/building-your-application/routing/middleware
-kreiramo middleware.js fajl
-u middleware.js fajlu kreiramo i eksportujemo funkciju middleware()
-u funkciju middleware() dodajemo izjavu return Response.json()
-kreiramo i eksportujemo varijablu objekt const config
-u pretrazivacu otvorimo rutu: http://localhost:3000/about
-u objekt config dodajemo niz matcher
-importujemo funkciju NextResponse iz paketa Next Server
-u funkciju middleware() dodajemo izjavu return NextResponse()
-u pretrazivacu otvorimo rutu: http://localhost:3000/about

50. Render (optional)
-otvorimo web stranicu: https://render.com/
-otvorimo link: https://dashboard.render.com/new/database
-kreiramo PostgreSQL Projekt udemy-nextjs-openai
-u .env fajl dodajemo vrijednost varijable External Database URL sa web servisa Render
-kreiramo example.env fajl za primjer varijabli koje je potrebno kreirati
-u shcema.prisma fajlu, u objektu datasource db dodajemo opciju provider = "postgresql"
-u terminalu ukucamo komandu npx prisma db push

51. PlanetScale
-otvorimo web stranicu: https://planetscale.com/

52. Local Build
-u package.json fajl dodajemo u komandu "build": "npx prisma generate && next build"
-u komponenti prisma-example/page.js dodajemo uslov if (tasks.length === 0)
-obrisemo sve taskove koje smo imali
-u terminalu ukucamo komandu npm run build
-u terminalu ukucamo komandu npm start

53. Force Dynamic
-otvorimo link: https://nextjs.org/docs/app/api-reference/file-conventions/route-segment-config
-u folderu app/tasks kreiramo loading.js fajl
-u loading.js fajlu kreiramo i eksportujemo funkciju loading()
-u komponenti tasks/page.js kreiramo i eksportujemo varijablu const dynamic
-u terminalu ukucamo komandu npm run build
-u terminalu ukucamo komandu npm start

54. Deploy
-otvorimo web stranicu: https://vercel.com/
-na web stranici Vercel kreiramo novi projekt
-odaberemo opciju da kod importujemo sa Github repozitorija
-u projekt dodajemo varijablu iz .env fajla


Section 02: GPTGenius App

55. Important Info !!!

56. Intro

57. New App
-preuzmemo starter folder gptgenius

58. First Pages
-u folderu app kreiramo folder (dashboard)
-u folderu (dashboard) kreiramo komponentu layout.js
-u folderu (dashboard) kreiramo foldere chat, profile i tours
-u folderima chat, profile i tours kreiramo komponente page.js

59. Home Page
-u komponenti app/page.js, u jsx-u kreiramo HTML elemente sa DaisyUI klasama
-importujemo komponentu Link iz paketa Next Link

60. Important Update !!!

61. Clerk Setup
-otvorimo web stranicu: https://clerk.com
-kreiramo fajlove .env.local i .env.local.example
-u .env.local fajlu kreiramo env varijable NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY i CLERK_SECRET_KEY
-u .env.local.example fajl dodajemo primjer varijabli koje je potrebno kreirati
-otvorimo link: https://www.npmjs.com/package/@clerk/nextjs
-otvorimo link: https://clerk.com/docs/quickstarts/nextjs
-u terminalu instaliramo paket Clerk sa komandom npm i @clerk/nextjs@5
-u komponentu app/layout.js importujemo komponentu ClerkProvider iz paketa Clerk
-u jsx-u dodajemo komponentu ClerkProvider sa otvorenim i zatvorenim tagom
-kreiramo middleware.ts fajl
-u middleware.ts fajl importujemo funkciju authMiddleware iz paketa Clerk
-kreiramo i eksportujemo funkciju authMiddleware()
-kreiramo i eksportujemo varijablu objekt const config
-u pretrazivacu otvorimo rutu: http://localhost:3000/chat

62. Custom Auth Pages
-u folderu app kreiramo foldere sign-up, [[...sign-up]] i komponentu page.js
-u komponenti page.js kreiramo i eksportujemo funkciju SignUpPage()
-u komponentu page.js importujemo komponentu SignUp iz paketa Clerk
-u folderu app kreiramo foldere sign-in, [[...sign-in]] i komponentu page.js
-u komponenti page.js kreiramo i eksportujemo funkciju SignInPage()
-u komponentu page.js importujemo komponentu SignIn iz paketa Clerk
-u .env.local fajlu kreiramo nove cetiri env varijable
-u komponente page.js za kreiranje racuna i prijavu kreiramo div element sa Tailwind CSS klasama

63. React Icons
-otvorimo web stranicu: https://react-icons.github.io/react-icons/

64. Dashboard Layout
-otvorimo link: https://daisyui.com/components/drawer/
-u folderu components kreiramo komponentu Sidebar.jsx
-u komponentu (dashboard)/layout.js importujemo komponentu Sidebar.jsx
-u jsx-u kreiramo HTML elemente sa Daisy UI klasama

65. Sidebar
-u folderu components kreiramo tri jsx komponente SidebarHeader, NavLinks i MemberProfile
-u komponentu Sidebar.jsx importujemo kreirane komponente
-roditelj div elementu dodajemo Tailwind CSS klase

66. Sidebar Header
-u folderu components kreiramo komponentu ThemeToggle.jsx
-u komponenti ThemeToggle.jsx, u jsx-u kreiramo btn element sa DaisyUI klasama
-u komponentu SidebarHeader.jsx importujemo komponentu ThemeToggle.jsx
-importujemo React ikonicu SiOpenaigym
-u jsx-u roditelj div elementu dodajemo Tailwind CSS klase
-kreiramo h2 element sa Tailwind CSS klasama
-u div element dodajemo komponentu ThemeToggle

67. Nav Links
-u komponentu NavLinks.jsx importujemo komponentu Link iz paketa Next Link
-kreiramo niz links sa objekt rutama
-u jsx-u kreiramo ul element sa DaisyUI klasama
-u ul elementu dodajemo metodu links?.map()
-u funkciji map kreiramo li element sa prop key
-u element li dodajemo komponentu Link sa prop href i className

68. Member Profile
-otvorimo link: https://clerk.com/docs/components/user/user-button
-otvorimo link: https://clerk.com/docs/references/nextjs/current-user
-otvorimo link: https://clerk.com/docs/references/nextjs/auth
-u komponentu MemberProfile.jsx importujemo komponentu UserButton iz paketa Clerk Nextjs
-u jsx-u roditelj div elementu dodajemo Tailwind CSS klase
-u div element dodajemo komponentu UserButton sa prop afterSignOutUrl
-importujemo funkcije currentUser i auth iz paketa Clerk Nextjs Server
-funkciji MemberProfile() dodajemo asinhronost
-u funkciju MemberProfile() pozivamo funkcije await currentUser() i auth()
-vrijednost funkcije await currentUser() pohranjujemo u varijablu const user
-vrijednost funkcije auth() pohranjujemo u destruktuiranu varijablu const { userId }
-u div elementu kreiramo p element u kojem dinamicki prikazujemo korisnikovu e-mail adresu

69. Theme Toggle
-otvorimo link: https://daisyui.com/docs/themes/
-u tailwind.config.js fajl dodajemo objekt daisyui
-u komponentu app/layout.js, html elementu dodajemo atribut data-theme
-u komponentu ThemeToggle.jsx dodajemo direktivu 'use client'
-importujemo Ract ikonice BsMoonFill i BsSunFill iz paketa React Icons
-kreiramo varijablu objekt const themes
-u funkciji ThemeToggle() kreiramo state varijablu const theme i set funciju setTheme
-funkciji useState() dodajemo argument themes.winte useState(themes.winter)
-u jsx-u kreiramo button elementu sa prop onClick i className
-u button element dodajemo uslov ternarni operator theme === 'winter'
-prvi dio ternarnog operatora je ikonica BsMoonFill, a drugi dio ternarnog operatora je ikonica BsSunFill
-kreiramo funkciju toggleTheme
-u dogadaj onClick proslijedujemo funkciju toggleTheme
-u funkciji toggleTheme() kreiramo varijablu const newTheme
-dodajemo metodu document.documentElement.setAttribute()
-dodajemo funkciju setTheme(newTheme)

70. Boilerplate Overview

71. User Profile
-otvorimo link: https://stackoverflow.com/questions/78529760/nextjs-clerk-the-signin-component-is-not-configured-correctly
-u komponentu profile/page.js importujemo komponentu UserProfile iz paketa Clerk Nextjs
-u folderu profile kreiramo folder [[...rest]]
-u folder [[...rest]] premjestamo komponentu page.js iz foldera profile

72. React Hot Toast Library
-otvorimo web stranicu: https://react-hot-toast.com/
-otvorimo link: https://www.npmjs.com/package/react-hot-toast
-u terminalu instaliramo paket sa komandom npm i react-hot-toast
-u folderu app kreiramo komponentu providers.jsx
-u komponentu providers.jsx dodajemo direktivu 'use client'
-kreiramo i eksportujemo kao default funkciju Providers()
-funkciji Providers() dodajemo parametar destruktuirani prop children
-importujemo komponentu Toaster iz paketa React Hot Toast
-u jsx-u dodajemo prazan fragment kao roditelj element
-u prazan fragment dodajemo komponentu Toaster sa prop position
-ispod komponente Toaster dodajemo prop children
-u komponentu app/layout.js importujemo komponentu Providers
-u body element dodajemo komponentu Providers sa otvorenim u zatvorenim tagom
-u komponentu Providers dodajemo prop children
-u komponenti MemberProfile.jsx, komponenti UserButton dodajemo prop fallbackRedirectUrl umjesto prop afterSignOutUrl

73. Chat Structure
-u folderu components kreiramo komponentu Chat.jsx
-u komponentu chat/page.js importujemo komponentu Chat.jsx
-u komponentu Chat.jsx dodajemo direktivu 'use client'
-importujemo funkciju useState() iz paketa React
-kreiramo state varijable const text i const message
-kreiramo set funkcije setText i setMessage
-kreiramo funkciju handleSubmit() sa parametar e
-u funkciju handleSubmit() dodajemo metodu e.preventDefault()
-u jsx-u roditelj div elementu dodajemo Tailwind CSS klase
-u roditelj div elementu kreiramo div element i unutar njega h2 element
-u roditelj div elementu kreiramo form element sa prop onSubmit i className
-u form elementu kreiramo div element sa DaisyUI klasama
-u div elementu kreiramo elemente input i button sa DaisyUI klasama
-input elementu dodajemo prop type, placeholder, className, value, required i onChange
-button elementu dodajemo prop className i type
-form elementu dodajemo dogadaj onSubmit i prop className
-u dogadaj onSubmit proslijedujemo funkciju handleSubmit

74. React Query - Info
-otvorimo web stranicu: https://tanstack.com/query/v5/docs/framework/react/overview
-u terminalu instaliramo React Query pakete sa komandom npm i @tanstack/react-query @tanstack/react-query-devtools

75. React Query - Setup
-kreiramo fodler utils i actions.js fajl
-u actions.js fajlu kreiramo i eksportujemo asinhronu funkciju generateChatResponse() sa parametrom chatMessage
-importujemo funkciju useState iz paketa React
-u komponentu providers.jsx importujemo funkciju QueryClient, komponente QueryClientProvider i ReactQueryDevtools iz paketa Tanstack
-pozivamo funkciju useState() i unutar funkcije anonimnu funkciju
-u anonimnu funkciju dodajemo funkciju new QueryClient()
-vrijednost funkcije useState pohranjujemo u varijablu const [queryClient]
-u jsx-u dodajemo komponentu QueryClientProvider sa otvorenim i zatvorenim tagom 
-komponenti QueryClientProvider dodajemo prop client
-u prop client proslijedujemo vrijednost varijable queryClient
-u komponentu QueryClientProvider dodajemo komponentu ReactQueryDevtools
-u komponentu chat/page.js importujemo funkcije dehydrate, QueryClient i komponentu HydrationBoundary
-u jsx-u dodajemo komponentu HydrationBoundary kao roditelj element sa otvorenim i zatvorenim tagom
-komponenti HydrationBoundary dodajemo prop state
-u prop state proslijedujemo funkciju dehydrate(queryClient)
-u komponentu Chat importujemo funkcije useMutation i generateChatResponse iz paketa Tanstack
-u funkciji Chat() pozivamo funkciju useMutation()
-vrijednost funkcije useMutation() pohranjujemo u destruktuiranu varijablu const { mutate }
-u funkciju useMutation() dodajemo objekt i funkciju mutationFn
-u funkciju handleSubmit() dodajemo funkciju mutate(text) 

76. OpenAI - Pricing
-otvorimo web stranicu: https://openai.com/pricing

77. OpenAI - Playground
-otvorimo link: https://platform.openai.com/playground/chat?models=gpt-3.5-turbo

78. OpenAI - Docs
-otvorimo link: https://platform.openai.com/docs/overview

79. First Prompt
-otvorimo link: https://www.npmjs.com/package/openai
-u .env fajlu kreiramo env varijablu OPENAI_API_KEY
-u .env.example fajlu kreiramo primjer env varijable koju je potrebno kreirati
-u actions.js fajlu, importujemo funkciju OpenAI iz paketa OpenAI
-dodajemo metodu new openAi()
-vrijednost metode new openAi() pohranjujemo u varijablu const openai
-u funkciju generateChatResponse() dodajemo metodu await openai.chat.completions.create()
-vrijednost metode await openai.chat.completions.create() pohranjujemo u varijablu const response
-u funkciju create() dodajemo konfiguracioni objekt
-u konfiguracioni objekt dodajemo opcije messages, model i temperature

80. Context
-u actions.js fajlu, funkciji generateChatResponse() dodajemo parametar chatMessages
-u izjavu return dodajemo response.choices[0].message
-dodajemo blokove koda try - catch
-u blok koda try dodajemo varijablu const response i izjavu return
-u blok koda catch dodajemo izjavu return null
-u komponenti Chat.jsx, funkciji mutationFn dodajemo parametar query
-funkciji generateChatResponse() dodajemo argument niz [...messages, query]
-u funkciji handleSubmit() kreiramo varijablu const query
-dodajemo funkciju mutate(query)
-dodajemo funkciju setMessages()
-u funkciju setMessages() proslijedujemo anonimnu funkciju sa parametrom prev
-dodajemo funkciju setText('')
-u funkciju useMutation() dodajemo funkcije onSuccess i onError
-importujemo instancu toast iz paketa React Hot Toast
-funkciji onSuccess() dodajemo parameter data
-u funkciju onSuccess dodajemo uslov if (!data)
-u uslov if (!data) dodajemo funkciju toast.error()
-u funkciju onSuccess() dodajemo funkciju setMessages()
-u funkciju setMessages() proslijedujemo anonimnu funkciju sa parametrom prev
-u funkciju onError() dodajemo funkciju toast.error()

81. Display Messages
-u komponenti Chat.jsx, destruktuiramo varijablu isPending iz funkcije useMutation()
-u jsx-u button elementu dodajemo prop disabled
-u prop disabled proslijedujemo vrijednost varijable isPending
-u button element dodajemo ternarni uslov isPending ?
-u prvi div element unutar roditelj div elementa dodajemo metodu messages?.map()
-u funkciji map() kreiramo dvije varijable const avatar i const bcg
-dodajemo izjavu return
-u izjavi return kreiramo div element sa prop key i className
-u prop className dodajemo dinamicku klasu bcg
-u div elementu kreiramo elemente span i p
-u div element dodajemo ternarni uslov isPending ?

82. New Tour - Setup
-u folderu tours kreiramo folder new-tour i komponentu page.js
-u komponenti new-tour/page.js kreiramo i eksportujemo funkciju NewTourPage()
-funkciji NewTourPage() dodajemo asinhronost
-u komponentu new-tour/page.js importujemo funkcije dehydrate, QueryClient i komponentu HydrationBoundary iz paketa Tanstack
-kreiramo varijablu const queryClient
-u jsx-u dodajemo komponentu HydrationBoundary sa otvorenim i zatvorenim tagom
-komponenti HydrationBoundary dodajemo prop state
-u prop state proslijedujemo funkciju dehydrate(queryClient)
-u folderu components kreiramo komponentu NewTour.jsx
-u komponentu new-tour/page.js importujemo komponentu NewTour.jsx
-ujsx-u, u komponentu HydrationBoundary dodajemo komponentu NewTour

83. New Tour - Form
-u folderu components kreiramo komponentu TourInfo.jsx
-u komponentu NewTour.jsx importujemo komponentu TourInfo.jsx
-dodajemo direktivu 'use client'
-kreiramo funkciju handleSubmit() sa parametrom e
-u funkciju handleSubmit() dodajemo metodu e.preventDefault()
-kreiramo varijable const formData i const destination
-u jsx-u dodajemo roditelj element prazan fragment
-u praznom fragmentu kreiramo form element i div element
-u form elementu kreiramo elemente h2, div, input i button
-input elementima dodajemo prop type, className, placeholder, name i required
-HTML elementima dodajemo DaisyUI klase
-button elementu dodajemo prop submit
-form elementu dodajemo dogadaj onSubmit i prop className
-u prop onSubmit proslijedujemo funkciju handleSubmit
-u div element dodajemo komponentu TourInfo

84. New Tour - React Query
-u utils/actions.js fajlu kreiramo i eksportujemo asinhrone funkcije getExistingTour(), generateTourResponse() i createNewTour()
-u komponentu NewTour.jsx importujemo funkcije useMutation i useQueryClient iz paketa Tanstack
-importujemo funkcije createNewTour, generateTourResponse i getExistingTour iz actions.js fajla
-u funkciji NewTour() pozivamo funkciju useMutation()
-vrijednost funkcije useMutation() pohranjujemo u destruktuirane varijable const { mutate, isPending, data: tour }
-u funkciju useMutation() dodajemo konfiguracioni objekt
-u konfiguracioni objekt dodajemo key - value par mutationFn i anonimnu asinhronu funkciju sa parametrom destination
-u anonimnu funkciju dodajemo metodu await generateTourResponse()
-vrijednost metode await generateTourResponse() pohranjujemo u varijablu const newTour
-dodajemo uslov if (newTour)
-u uslov if (newTour) dodajemo izjavu return newTour
-dodajemo funkciju toast.error()
-dodajemo izjavu return null
-u funkciju handleSubmit() dodajemo funkciju mutate(destination)
-dodajemo uslov if (isPending)
-u uslovu if (isPending) kreiramo span element sa DaisyUI klasama
-nakon form elementa, u div elementu kreiramo div element 
-u div element dodajemo ternarni uslov tour ?
-komponenti Tour dodajemo prop tour

85. Tour Prompt

86. Generate Tour Response
-u actions.js fajlu, u funkciju generateTourResponse() dodajemo blokove koda try - catch
-u blok koda try dodajemo metodu openai.chat.completions.create()
-u funkciju create() dodajemo konfiguracioni objekt
-u konfiguracioni objekt dodajemo opcije messages, model i temperature 
-kreiramo varijablu const query
-vrijednost metode await openai.chat.completions.create() pohranjujemo u varijablu const response
-kreiramo varijablu const tourData
-dodajemo uslov if (!tourData.tour)
-u uslov if (!tourData.tour) dodajemo izjavu return null
-u blok koda catch dodajemo izjavu return null
-u komponenti TourInfo.jsx, funkciji TourInfo() dodajemo parametar destruktuirani prop tour
-otvorimo rutu: http://localhost:3000/tours/new-tour
-unesemo podatke za grad, drzavu i kliknemo dugme za generisanje ture

87. Tour Info
-u komponenti TourInfo.jsx, destruktuiramo varijable const { title, description, stops } iz prop tour
-u jsx-u kreiramo HTML elemente h1, p, ul i li sa Tailwind CSS klasama
-u ul element dodajemo metodu stops?.map()
-u funkciju map() dodajemo izjavu return
-u izjavi return kreiramo li element sa prop key i className
-u li elementu kreiramo p element sa prop className  

88. PlanetScale
-otvorimo web stranicu: https://planetscale.com/
-u terminalu instaliramo pakete Prisma i Prisma Client
-u terminalu ukucamo komandu npx prisma init
-generisemo .env fajl sa env varijablom DATABASE_URL
-otvorimo link: https://www.prisma.io/docs/orm/overview/databases/sqlite
-kreiramo .env.example fajl u koji dodajemo primjer varijable koju je potrebno kreirati
-u folderu utils kreiramo db.ts fajl

89. Tour Model
-u schema.prisma fajlu kreiramo model Tour
-u terminalu ukucamo komandu npx prisma migrate dev
-u terminalu ukucamo komandu npx prisma studio

90. Save Tour
-u actions.js fajlu importujemo instancu prisma iz folder db
-u funkciji createNewTour() dodajemo izjavu return prisma.tour.findUnique()
-u funkciju createNewTour() dodajemo izjavu return prisma.tour.create()
-u komponenti NewTour.jsx,u funkciji NewTour() pozivamo funkciju useQueryClient()
-vrijednost funkcije useQueryClient() pohranjujemo u varijablu const queryClient
-u kljucu mutationFn, u anonimnu funkciju dodajemo funkciju await getExistingTour(destination)
-vrijednost metode await getExistingTour(destination) pohranjujemo u varijablu const existingTour
-dodajemo uslov if (existingTour)
-u uslov if (newTour) dodajemo funkciju await createNewTour(newTour)
-dodajemo metodu queryClient.invalidateQueries()
-dodajemo izjavu return newTour

Save Tour - fixed
-u actions.js fajlu, u funkciji getExistingTour(), vrijednost metode await prisma.tour.findUnique() pohranjujemo u varijablu const tour
-dodajemo uslov if (tour)
-u funkciji createNewTour(), u funkciji create(), dodajemo objekt data
-u folderu utils kreiramo utils.js fajl
-u utils.js fajlu kreiramo i eksportujemo funkciju toProperCase(str)
-u komponentu NewTour.jsx importujemo funkciju toProperCase()
-u metodu Object.fromEntries() dodajemo metodu Array.from() 

91. Timeout Info

92. GetAllTours Function
-u actions.js fajlu kreiramo i eksportujemo asinhronu funkciju getAllTours() sa parametrom searchTerm
-u funkciju getAllTours() dodajemo metodu if (!searchTerm)
-u uslov if (!searchTerm) dodajemo metodu await prisma.tour.findMany()
-vrijednost metode await prisma.tour.findMany() pohranjujemo u varijablu const tours
-nakon uslova if dodajemo izjavu return tours
-dodajemo metodu await prisma.tour.findMany()
-vrijednost metode await prisma.tour.findMany() pohranjujemo u varijablu const tours
-u funkciju findMany() dodajemo konfiguracioni objekt findMany()
-u konfiguracioni objekt findMany() dodajemo objekte where i orderBy
-u objekt where dodajemo niz OR
-dodajemo izjavu return tours

93. Tours Page - Setup
-u folderu components kreiramo tri jsx komponente: ToursPage, ToursList i TourCard
-u folderu app/tours kreiramo komponentu loading.js
-u komponentu tours/page.js importujemo funkcije dehydrate, QueryClient i komponentu HydrationBoundary iz paketa Tanstack
-importujemo funkciju getAllTours iz foldera utils
-importujemo komponentu ToursPage.jsx
-preimenujemo funkciju ToursPage() u AllToursPage()
-funkciji AllToursPage() dodajemo asinhronost
-u funkciji AllToursPage() kreiramo varijablu const queryClient
-dodajemo metodu queryClient.prefetchQuery()
-funkciji prefetchQuery() dodajemo konfiguracioni objekt
-u konfiguracioni objekt dodajemo kljuceve queryKey i queryFn
-u jsx-u dodajemo komponentu HydrationBoundary kao roditelj element
-komponente HydrationBoundary dodajemo prop state
-u prop state proslijedujemo funkciju dehydrate(queryClient)
-u komponentu HydrationBoundary dodajemo komponentu ToursPage

94. Tours List
-u komponentu ToursPage.jsx dodajemo direktivu 'use client'
-importujemo funkciju getAllTours iz foldera utils
-importujemo funkciju useQuery iz paketa Tanstack
-importujemo komponentu ToursList.jsx
-u funkciji ToursPage() pozivamo funkciju useQuery()
-vrijednost funkcije useQuery() pohranjujemo u destruktuirane varijable const { data, isPending }
-u jsx-u dodajemo prazan fragment kao roditelj element
-u komponenti ToursList.jsx, funkciji ToursList() dodajemo parametar destruktuirani prop data
-dodajemo uslov if (data.length === 0)
-u uslovu if kreiramo h4 element
-u jsx-u, roditelj div elementu kreiramo Tailwind CSS Grid klase
-u div element dodajemo metodu data?.map()
-importujemo komponentu TourCard.jsx
-u funkciju map() dodajemo komponentu TourCard sa prop key i tour
-u komponentu TourCard.jsx importujemo komponentu Link iz paketa Next Link
-destruktuiramo varijable const { city, title, id, country } iz varijable tour
-u jsx-u dodajemo komponentu Link kao roditelj element
-komponenti Link dodajemo prop href i className
-u komponenti Link kreiramo elemente div i h2
-komponenti Link i HTML elementima dodajemo DaisyUI klase

95. Search Functionality
-u komponenti ToursPage.jsx, u jsx-u kreiramo form element kao roditelj element
-u form elementu kreiramo div element
-u div elementu kreiramo elemente input i button
-input elementima dodajemo prop type, placeholder, className, name, value, onChange i required
-importujemo funkciju useState iz paketa React
-kreiramo state varijablu const searchValue i set funkciju setSearchValue
-u prop value proslijedujemo varijablu searchValue
-u dogadaj onChange proslijedujemo anonimnu funkciju sa parametrom e
-u anonimnu funkciju proslijedujemo funkciju setSearchValue(e.target.value)
-button elementu dodajemo prop className, type, disabled i onClick
-u prop disabled proslijedujemo varijablu isPending
-u dogadaj onClick proslijedujemo anonimnu funkciju
-u anonimnu funkciju proslijedujemo funkciju setSearchValue
-u button element dodajemo ternarni uslov isPending ?
-u kljuc queryKey dodajemo u niz varijablu searchValue
-u kljuc queryFn dodajemo u funkciju getAllTours varijablu searchValue
-u komponentu tours/page.js, u kljuc queryKey, u niz dodajemo vrijednost prazan string ''

96. Single Tour Page
-u folderu tours kreiramo folder id i komponentu page.js
-u folderu tours/[id]/page.js kreiramo i eksportujemo kao default funkciju SingleTourPage
-u actions.js fajlu kreiramo i eksportujemo asinhronu funkciju getSingleTour() sa paratrom id
-dodajemo izjavu return prisma.tour.findUnique()
-u funkciju findUnique() dodajemo konfiguracioni objekt
-u konfiguracioni objekt dodajemo objekt where
-u komponentu [id]/page.js importujemo funkcije redirect i getSingleTour
-importujemo komponente Link i TourInfo.jsx
-u funkciju SingleTourPage() dodajemo funkciju await getSingleTour(params.id)
-vrijednost funkcije await getSingleTour(params.id) pohranjujemo u varijablu const tour
-dodajemo uslov if (!tour)
-u uslov if (!tour) dodajemo funkciju redirect('/tours')
-u jsx-u u roditelj div element dodajemo komponente Link i TourInfo
-komponenti Link dodajemo prop href i className
-komponenti TourInfo dodajemo prop tour
-u komponenti TourInfo.jsx kreiramo varijablu const parsedStops

97. Generate Image
-u actions.js fajlu kreiramo i eksportujemo asinhronu funkciju generateTourImage() 
-funkciji generateTourImage() dodajemo parametre destruktuirane prop city i country
-dodajemo blokove koda try - catch
-u blok koda try dodajemo metodu await openai.images.generate()
-vrijednost metode await openai.images.generate() pohranjujemo u varijablu const tourImage
-dodajemo izjavu return tourImage?.data[0]?.url
-u blok koda catch dodajemo izjavu return null
-u komponentu tours/[id]/page.js importujemo funkciju generateTourImage i komponentu Image
-u funkciji SingleTourPage() dodajemo metodu await generateTourImage()
-vrijednost metode await generateTourImage() pohranjujemo u varijablu const tourImage
-u jsx-u dodajemo uslov ternarni operator tourImage ?
-u prvi dio ternarnog operatora kreiramo div element sa komponentom Image
-komponenti Image dodajemo vise prop
-u drugi dio ternarnog operatora dodajemo vrijednost null
-u next.config.js fajl, u niz remotePatterns dodajemo dva objekta

98. Unsplash API
-u .env.local fajlu kreiramo env varijablu UNSPLASH_API_KEY
-u .env.local.example fajlu dodajemo primjer varijable koju je potrebno kreirati
-u komponentu tours/[id]/page.js importujemo instancu axios iz paketa Axios
-kreiramo varijablu const url
-pozivamo funkciju await axios()
-vrijednost funkcije await axios() pohranjujemo u destruktuiranu varijablu const { data }
-kreiramo varijablu const tourImage

99. Custom Pages - Bug/Fix
-u folderu app obrisemo foldere sign-in i sign-up
-u .env.local fajlu izbrisemo cetiri env varijable

100. Tokens - Intro

101. Max Tokens
-otvorimo web stranicu https://clerk.com/
-u actions.js fajlu, u funkciji generateChatResponse() dodajemo kljuc max_tokens

102. Token Actions
-u schema.prisma fajlu kreiramo model Token
-u terminalu ukucamo komandu npx prisma db push
-u actions.js fajlu kreiramo i eksportujemo asinhronu funkciju fetchUserTokensById() sa parametrom clerkId
-u funkciju fetchUserTokensById() dodajemo metodu await prisma.token.findUnique()
-vrijednost metode await prisma.token.findUnique() pohranjujemo u varijablu const result
-dodajemo izjavu return result?.tokens
-kreiramo i eksportujemo asinhronu funkciju generateUserTokensForId() sa parametrom clerkId
-dodajemo metodu await prisma.token.create()
-vrijednost metode await prisma.token.create() pohranjujemo u varijablu const result
-dodajemo izjavu return result?.tokens
-kreiramo i eksportujemo asinhronu funkciju fetchOrGenerateTokens() sa parametrom clerkId
-u funkciju fetchOrGenerateTokens() dodajemo metodu await fetchUserTokensById(clerkId)
-vrijednost metode await fetchUserTokensById(clerkId) pohranjujemo u varijablu const result
-dodajemo uslov if (result)
-u uslov if (result) dodajemo izjavu return result.tokens
-nakon uslova if dodajemo izjavu return (await generateUserTokensForId(clerkId)).tokens
-kreiramo i eksportujemo asinhronu funkciju subtractTokens() sa parametrima clerkId i tokens
-u funkciju subtractTokens() dodajemo metodu await prisma.token.update()
-vrijednost metode await prisma.token.update() pohranjujemo u varijablu const result
-u funkciju update() dodajemo konfiguracioni objekt
-u konfiguracioni objekt dodajemo objekte where i data
-importujemo funkciju revalidatePath() iz paketa Next Cache
-dodajemo funkciju revalidatePath('/profile')
-dodajemo izjavu return result.tokens

103. Display Tokens
-u komponentu MemberProfile.jsx importujemo funkciju fetchOrGenerateTokens iz foldera utils
-u funkciji MemberProfile() pozivamo funkciju await fetchOrGenerateTokens(userId)
-u komponenti profile/page.js, u jsx-u kreiramo div element kao roditelj element
-funkciji ProfilePage() dodajemo asinhronost
-importujemo funkciju fetchUserTokensById iz foldera utils
-u div elementu kreiramo h2 element sa Tailwind CSS klasama
-u funkciju ProfilePage() pozivamo funkciju auth()
-vrijednost funkcije auth() pohranjujemo u destruktuiranu varijablu const { userId }
-pozivamo funkciju await fetchUserTokensById(userId)
-vrijednost funkcije await fetchUserTokensById(userId) pohranjujemo u varijablu const currentTokens
-kreiramo i eksportujemo varijablu const dynamic

104. Tours Logic
-u komponentu NewTour.jsx importujemo funkciju fetchUserTokensById
-importujemo funkciju useAuth iz paketa Clerk Nextjs
-u funkciju NewTour() pozivamo funkciju useAuth()
-vrijednost funkcije useAuth() pohranjujemo u destruktuiranu varijablu const { userId }
-u funkciji mutationFn pozivamo funkciju await fetchUserTokensById(userId)
-vrijednost funkcije wait fetchUserTokensById(userId) pohranjujemo u varijablu const currentTokens
-dodajemo uslov if (currentTokens < 300)
-dodajemo uslov if (!newTour)
-u uslov if (!newTour) dodajemo funkcije toast.error()
-vrijednost funkcije await createNewTour(newTour.tour) pohranjujemo u varijablu const response
-importujemo funkciju subtractTokens
-pozivamo funkciju await subtractTokens(userId, newTour.tokens)
-vrijednost funkcije subtractTokens() pohranjujemo u varijablu const newTokens
-dodajemo funkciju toast.success()
-dodajemo izjavu return newTour.tour

105. Chat Logic
-u actions.js fajlu, u funkciju generateChatResponse() dodajemo izjavu return objekt sa kljucevima message i tokens 
-u komponentu Chat.jsx importujemo funkciju useAuth() iz paketa Clerk Nextjs
-u funkciji Chat() pozivamo funkciju useAuth()
-vrijednost funkcije useAuth() pohranjujemo u destruktuiranu varijablu const { userId }
-u funkciju useMutation() dodajemo kljuc mutationFn
-kljucu mutationFn dodjeljujemo vrijednost asinhrone anonimne funkcije sa parametrom query
-importujemo funkciju fetchUserTokensById iz foldera utils
-u anonimnoj funkciji() pozivamo funkciju await fetchUserTokensById(userId)
-vrijednost funkcije fetchUserTokensById(userId) pohranjujemo u varijablu const currentTokens
-dodajemo uslov if (currentTokens < 300)
-u uslov if (currentTokens < 300) dodajemo funkciju toast.error()
-pozivamo funkciju await generateChatResponse()
-vrijednost funkcije await generateChatResponse() pohranjujemo u varijablu const response
-dodajemo uslov if (!response)
-u uslov if (!response) dodajemo funkciju toast.error()
-pozivamo funkciju await subtractTokens(userId, response.tokens)
-vrijednost funkcije await subtractTokens(userId, response.tokens) pohranjujemo u varijablu const newTokens
-dodajemo funkciju toast.success()

106. Deploy
-otvorimo web stranicu: https://vercel.com/
-kreiramo novi projekt

107. Switch to Clerk 5


Section 03: Jobify

108. Important Info !!!

109. Intro

110. Setup
-preuzmemmo starter folder jobify
-u terminalu ukucamo komande npm install i npm run dev

111. Shadcn-ui
-otvorimo web stranicu: https://ui.shadcn.com/
-otvorimo link: https://lucide.dev/guide/packages/lucide-react
-u komponentu app/page.tsx importujemo komponente Button i Camera
-u jsx-u div roditelj elementu dodajemo Tailwind CSS flex klase
-u div element dodajemo dvije komponente Button
-u drugu komponentu Button dodajemo komponentu Camera
-komponenti Button dodajemo prop variant i size

112. Shadcn-ui API

113. Layout and Homepage
-otvorimo web stranicu: https://undraw.co/
-u komponentu app/page.tsx importujemo komponente Image, Link, slike Logo i LandingImg
-u jsx-u dodajemo element main kao roditelj element
-u main elementu kreiramo header element sa Tailwind CSS klasama
-u header element dodajemo komponentu Image sa prop src i alt
-u main elementu kreiramo section element sa Tailwind CSS Grid klasama
-u section elementu kreiramo div element 
-u div elementu kreiramo elemente h1 i p sa Tailwind CSS klasama
-u div element dodajemo komponentu Button sa prop asChild i className
-u komponentu Button dodajemo komponentu Link sa prop href
-u section element dodajemo komponentu Image sa prop src, alt i className

114. Create Pages
-u folderu app kreiramo folder (dashboard)
-u folderu (dashboard) kreiramo foldere add-job, jobs, stats i komponente page.tsx
-u folderu (dashboard) kreiramo komponentu layout.tsx
-u komponenti layout, funkciji layout() dodajemo parametar destruktuirani prop children sa tipom

115. Important Update !!!
-Clerk package update

116. Clerk Auth
-otvorimo web stranicu: https://clerk.com/
-na web stranici Clerk kreiramo novi projekt
-kreiramo fajlove .env.local i .env.local.example
-u .env.local fajl dodajemo dvije CLERK env varijable
-u .env.local.example fajl dodajemo primjer varijable koje je potrebno kreirati
-u komponentu layout.tsx importujemo komponentu ClerkProvider
-u jsx-u dodajemo komponentu ClerkProvider sa otvorenim i zatvorenim tagom
-kreiramo komponentu middleware.tsx
-u komponentu middleware.tsx importujemo funkciju authMiddleware iz paketa Next Clerk Next.js

117. Nav Links
-kreiramo folder utils i komponentu links.tsx
-u komponentu links.tsx importujemo tri React ikonice
-kreiramo tip NavLink
-kreiramo niz const links sa tipom NavLink

118. Dashboard Layout
-u folderu components kreiramo tsx komponente: Navbar, Sidebar, LinksDropdown i ThemeToggle 
-u komponentu (dashboard)/layout.tsx importujemo tip PropsWithChildren iz paketa React
-importujemo komponente Navbar.tsx i Sidebar.tsx
-u funkciji layout(), parametru children dodajemo tip PropsWithChildren
-u jsx-u kreiramo main element sa Tailwind CSS Grid klasama
-u main elementu kreiramo dva div elementa sa Tailwind CSS Grid klasama
-u prvi div element dodajemo komponentu Sidebar
-u drugi div element dodajemo komponentu Navbar
-u drugom div element kreiramo div element sa Tailwind CSS klasama
-u div element dodajemo prop children

119. Sidebar
-u komponenti links.tsx, niz links eksportujemo kao default
-u komponentu Sidebar.tsx dodajemo direktivu 'use client'
-importujemo funkciju usePathname iz paketa Next Navigation
-u funkciji Sidebar() pozivamo funkciju usePathname()
-vrijednost funkcije usePathname() pohranjujemo u varijablu const pathname
-importujemo komponentu Image i Link iz paketa Next
-importujemo komponentu Button iz folder ui/button.tsx
-importujemo sliku Logo i niz links
-u jsx-u kreiramo aside element kao roditelj element sa Tailwind CSS klasama
-u aside element dodajemo komponentu Image sa prop src, alt i className
-kreiramo div element sa Tailwind CSS klasama
-u div element dodajemo metodu links?.map()
-u funkciji map(), u izjavi return dodajemo komponentu Button kao roditelj element
-komponenti Button dodajemo prop asChild, key i variant
-u komponentu Button dodajemo komponentu Link sa prop href i className
-u komponenti Link kreiramo dva span elementa sa Tailwind CSS klasama
-u prop variant dodajemo uslov ternarni operator pathname === link.href ?

120. Navbar
-u komponentu Navbar.tsx importujemo komponentu UserButton iz paketa Clerk Next
-importujemo komponente LinksDropdown.tsx i ThemeToggle.tsx
-u jsx-u kreiramo nav element kao roditelj element sa Tailwind CSS klasama
-u nav elementu kreiramo dva div elementa
-u prvi div element dodajemo komponentu LinksDropdown
-u drugi div element dodajemo komponente ThemeToggle i UserButton
-drugom div elementu dodajemo Tailwind CSS Flex klase
-komponenti UserButton dodajemo prop afterSignOutUrl

121. Dropdown Links
-otvorimo link: https://ui.shadcn.com/docs/components/dropdown-menu
-u terminalu ukucamo komandu: npx shadcn@latest add dropdown-menu
-u komponentu LinksDropdown.tsx importujemo komponente DropdownMenu, DropdownMenuContent, DropdownMenuItem i DropdownMenuTrigger iz komponente ui/dropdown-menu.tsx
-importujemo komponentu Button iz komponente ui/button.tsx
-importujemo React ikonicu AlignLeft iz paketa Lucide React
-importujemo komponentu Link iz paketa Next Link
-importujemo niz links iz utils/links.tsx fajla
-u jsx-u dodajemo komponentu DropdownMenu kao roditelj element
-u komponentu DropdownMenu dodajemo komponentu DropdownMenuTrigger sa otvorenim i zatvorenim tagom 
-komponenti DropdownMenuTrigger dodajemo prop asChild i className
-u komponentu DropdownMenuTrigger dodajemo komponentu Button sa prop variant i size
-u komponenti Button kreiramo dva span elementa sa Tailwind CSS klasama
-u prvi span element dodajemo komponentu AlignLeft
-u drugi span element dodajemo tekst sa klasom sr-only (dokumentacija)
-u komponentu DropdownMenu dodajemo komponentu DropdownMenuContent sa otvorenim i zatvorenim tagom
-komponenti DropdownMenuContent dodajemo prop className, align i sideOffset
-u komponentu DropdownMenuContent dodajemo metodu links?.map()
-u funkciji map(), u return izjavu dodajemo komponentu DropdownMenuItem sa otvorenim i zatvorenim tagom
-komponenti DropdownMenuItem dodajemo prop key
-u komponentu DropdownMenuItem dodajemo komponentu Link sa prop href i className
-u komponenti Link kreiramo dva span elementa sa Tailwind CSS klasama

122. Change Theme
-otvorimo link: https://ui.shadcn.com/docs/theming
-otvorimo link: https://ui.shadcn.com/themes
-u globals.css fajl dodajemo kod za direktivu @layer base

123. Toggle Theme
-u folderu app kreiramo komponentu providers.tsx
-u komponenti providers kreiramo i eksportujemo kao default funkciju Providers()
-funkciji Providers dodajemo parametar destruktuirani prop children sa tipom
-u komponentu app/layout.tsx importujemo komponentu Providers iz komponente providers.tsx
-u jsx-u html elementu dodajemo prop suppressHydrationWarning
-u element body dodajemo komponentu Providers sa otvorenim i zatvorenim tagom
-u komponentu Providers dodajemo prop children
-otvorimo link: https://ui.shadcn.com/docs/dark-mode/next
-u terminalu instaliramo paket Next Themes sa komandom npm install next-themes
-u folderu components kreiramo komponentu theme-provider.tsx
-u komponentu providers.tsx importujemo komponentu ThemeProvider iz komponente theme-provider.tsx
-u jsx-u dodajemo komponentu ThemeProvider sa otvorenim i zatvorenim tagom
-komponenti ThemeProvider dodajemo prop attribute, defaultTheme, enableSystem i disabled
-u komponentu ThemeProvider dodajemo prop children
-u komponentu ThemeToggle.tsx dodajemo kod iz dokumentacije

124. Shadcn-ui Forms
-otvorimo link: https://ui.shadcn.com/docs/components/form
-otvorimo link: https://www.npmjs.com/package/@hookform/resolvers
-otvorimo link: https://www.npmjs.com/package/react-hook-form
-u terminalu ukucamo komandu: npx shadcn@latest add form input
-u folderu components kreiramo komponentu CreateJobForm.tsx
-u komponentu CreateJobForm.tsx importujemo * kao z iz paketa zod
-importujemo funkcije useForm i zodResolver
-importujemo komponente Button i Input iz foldera components/ui
-importujemo komponente Form, FormControl, FormField, FormItem, FormLabel i FormMessage iz komponente ui/form.tsx
-kreiramo varijablu const formSchema
-u funkciji CreateJobForm() kreiramo varijablu const form
-kreiramo funkciju onSubmit() sa parametrom values
-u jsx-u dodajemo komponentu Form sa otvorenim i zatvorenim tagom
-komponenti Form dodajemo prop {...form}
-u komponenti Form kreiramo form element sa prop onSubmit i className
-u prop onSubmit proslijedujemo funkciju form.handleSubmit(onSubmit)
-u form element dodajemo komponente FormField i Button
-komponenti FormField dodajemo prop control, name i render
-u komponentu add-job/page.tsx importujemo komponentu CreateJobForm.tsx

125. Types
-u folderu utils kreiramo types.ts fajl
-u types.ts fajl importujemo * kao z iz paketa zod
-kreiramo i eksportujemo tip JobType
-kreiramo i eksportujemo dva enuma JobStatus i JobMode
-dodajemo metodu z.object()
-vrijednost metode z.object() pohranjujemo u varijablu createAndEditJobSchema
-eksportujemo varijablu createAndEditJobSchema
-kreiramo i eksportujemo tipv CreateAndEditJobType

126. Custom Form Components
-otvorimo link: https://ui.shadcn.com/docs/components/select
-u folderu components kreiramo komponentu FormComponents.tsx
-u komponentu FormComponents.tsx importujemo komponente Form i Input iz foldera components/ui
-importujemo komponente FormControl, FormField, FormItem, FormLabel i FormMessage iz komponente ui/form.tsx
-importujemo komponente Select, SelectContent, SelectItem, SelectTrigger, i SelectValue iz komponente ui/select.tsx
-kreiramo i eksportujemo funkcije CustomFormField() i CustomFormSelect()
-kreiramo tip CustomFormFieldProps
-funkciji CustomFormField() dodajemo parametre destruktuirane prop name i constrol sa tipom CustomFormFieldProps
-u jsx-u dodajemo komponentu FormField sa prop control, name i render
-kreiramo tip CustomFormSelectProps
-funkciji CustomFormSelect() dodajemo parametre destruktuirane prop name, control, items i labelText
-parametrima dodajemo tip CustomFormSelectProps
-u jsx-u dodajemo komponentu FormField sa prop control, form i render
-u prop render proslijedujemo funkciju ({ field })
-u funkciju ({ field }) dodajemo komponentu FormItem
-u komponentu FormItem dodajemo komponente FormLabel, Select i FormMessage
-u komponentu Select dodajemo komponente FormControl i SelectContent
-u komponentu SelectContent dodajemo metodu items?.map()
-u funkciju map() dodajemo komponentu SelectItem

127. CreateJobForm Continued
-u komponentu CreateJobForm.tsx importujemo tipove iz types.ts fajla
-importujemo komponente CustomFormField i CustomFormSelect iz komponente FormComponents.tsx
-kreiramo varijablu const form
-kreiramo funkciju onSubmit sa parametrom values
-parametru values dodajemo tip CreateAndEditJobType
-u jsx-u, form elementu dodajemo prop onSubmit
-u prop onSubmit proslijedujemo funkciju form.handleSubmit(onSubmit)
-u form elementu kreiramo h2 element sa Tailwind CSS klasama
-kreiramo div element sa Tailwind CSS Grid klasama
-u div element dodajemo tri komponente CustomFormField sa prop name i control
-dodajemo dvije komponente CustomFormSelect
-komponentama CustomFormSelect dodajemo prop name, control, labelText i items

128. Render and Prisma
1. nacin Render
-otvorimo web stranicu: https://render.com/
-kreiramo novi projekt na web stranici Render
-otvorimo link: https://render.com/docs/postgresql-creating-connecting
2. nacin Neon
-otvorimo web stranicu: https://neon.tech/
-kreiramo novi projekt na web stranici Neon
3. nacin lokalno
-otvorimo link: https://www.prisma.io/docs/getting-started/quickstart-sqlite
-u .env fajl dodajemo u varijablu: DATABASE_URL="file:./dev.db"
-kreiramo .env.example fajl u koji dodajemo primjer varijable koju je potrebno kreirati
-u schema.prisma fajl dodajemo u objekt datasource db key - value par provider = "sqlite"
-otvorimo link: https://www.prisma.io/docs/guides/other/troubleshooting-orm/help-articles/nextjs-prisma-client-dev-practices#solution
-kreiramo folder utils i db.ts fajl
-u db.ts fajl kopiramo kod iz dokumentacije
-u schema.model fajlu kreiramo model Job
-u terminalu ukucamo komandu npx prisma migrate dev 
-odaberemo ime migracije: jobify-model
-generisemo folder migrations i fajlove unutar njega
-u terminalu ukucamo komandu npx prisma db push
-u terminalu ukucamo komandu npx prisma studio

129. CreateJobAction
-u folderu utils kreiramo actions.ts fajl
-u actions.ts fajl dodajemo direktivu 'use server'
-importujemo funkciju auth iz paketa Clerk Nextjs
-importujemo funkciju redirect iz paketa Next Navigation
-importujemo tipove JobType, CreateAndEditJobType i semu createAndEditJobSchema iz types.ts fajla
-importujemo instancu prisma iz db.ts fajla
-kreiramo i eksportujemo asinhronu funkciju createJobAction()
-funkciji createJobAction() dodajemo parametar values sa tipom CreateAndEditJobType
-funkciji createJobAction() dodajemo tip Promise<JobType | null>
-dodajemo blokove koda try - catch
-u blok koda catch dodajemo izjavu return null
-u blok koda try dodajemo metodu await await prisma.job.create()
-vrijednost metode await prisma.job.create() pohranjujemo u varijablu const job:JobType
-u funkciju create() dodajemo konfiguracioni objekt
-u konfiguracioni objekt dodajemo objekt data
-kreiramo funkciju authenticateAndRedirect()
-u funkciji authenticateAndRedirect() pozivamo funkciju auth()
-vrijednost funkcije auth() pohranjujemo u destruktuiranu varijablu const { userId }
-dodajemo uslov if (!userId) 
-u uslov if (!userId) dodajemo funkciju redirect('/')
-dodajemo izjavu return userId
-u funkciji createJobAction() pozivamo funkciju authenticateAndRedirect() sa tipom string
-vrijednost funkcije authenticateAndRedirect() pohranjujemo u varijablu const userId
-u objekt data dodajemo vrijednosti ...values i clerkId
-dodajemo izjavu return job
-u blok koda try dodajemo pozivamo funkciju createAndEditJobSchema.parse(values)
-dodajemo metodu await new Promise()

130. Toast Component
-otvorimo link: https://ui.shadcn.com/docs/components/toast
-u terminalu ukucamo komandu: npx shadcn@latest add toast