Udemy NextJS & Open AI Course John Smilga


Section 01: Next.js Tutorial

01. Course Resources

02. Discord Channel

03. Introduction to Next.js
-otvorimo web stranicu: https://nextjs.org/

04. Tutorial Overview

05. Update !!!
-instalirati verziju 14 Next.js

06. Create New Next.js App
-u terminalu ukucamo komandu npx create-next-app@14 nextjs-tutorial

07. Files and Folder Structure
-u nextjs-tutorial/README.md fajl dodan opis izrade projekta

08. Home Page
-u app/page.js komponenti kreiramo i eksportujemo kao default funkciju HomePage()

09. More Pages
-u folderu app kreiramo folder about i komponentu page.js
-u about/page.js komponenti kreiramo i eksportujemo kao default funkciju AboutPage()
-otvorimo rutu http://localhost:3000/about

10. Link Component
-otvorimo link: https://nextjs.org/docs/pages/api-reference/components/link
-u komponentu app/page.js importujemo komponentu Link
-u roditelj div element dodajemo komponentu Link sa otvorenim i zatvorenim tagom
-komponenti Link dodajemo prop href i className
-ponovimo isti postupak u komponenti about/page.js

11. Nested Routes
-u folderu about kreiramo folder info i komponentu page.js

Quiz 1: Fundamentals Quiz

12. First Challenge
-u folderu app kreiramo folder client, drinks, prisma-example, query i tasks
-u svakom folderu kreiramo komponente page.js

13. CSS
-otvorimo web stranicu: https://daisyui.com/
-otvorimo web stranicu: https://tailwindcss.com/
-otvorimo link: https://www.npmjs.com/package/daisyui
-otvorimo link: https://www.npmjs.com/package/@tailwindcss/typography
-u terminalu instaliramo pakete Daisy UI i Tailwind CSS Typography
-u terminalu ukucamo komande: npm i -D daisyui@3.9.4 i npm i @tailwindcss/typography

14. TailwindCSS

15. DaisyUI

16. Layout File
-u komponenti layout.js, promjenjen opis projekta u varijabli const metadata
-u jsx-u kreiran nav element 

17. Navbar Challenge
-kreiramo folder components i komponentu Navbar.jsx
-u komponentu Navbar.jsx importujemo komponentu Link
-kreiramo varijablu niz links
-kreiramo i eksportujemo funkciju Navbar() kao default
-u jsx-u kreiramo nav element sa Tailwind CSS klasama
-u nav elementu kreiramo div element sa Tailwind CSS klasama
-u div element dodajemo komponentu Link sa prop href i className
-kreiramo ul element sa Tailwind CSS klasama
-u ul element dodajemo metodu links?.map()
-u funkciji map(), u return izjavi kreiramo li element
-u li element dodajemo komponentu Link sa prop href i className
-u komponentu layout.js importujemo komponentu Navbar.jsx
-u jsx-u, u body element dodajemo komponentu Navbar
-kreiramo main element sa Tailwind CSS klasama
-u main elementu dinamicki prikazujemo prop children

18. Server Component vs Client Component
-otvorimo link: https://nextjs.org/docs/app/building-your-application/rendering/server-components
-otvorimo link: https://nextjs.org/docs/app/building-your-application/rendering/client-components

19. Counter Challenge
-u komponenti app/page.js, HTML elementima dodajemo Tailwind CSS klase
-u komponentu client/page.js importujemo funkciju useState iz paketa React
-kreiramo state varijablu const count i set funkciju setCount
-u jsx-u kreiramo button element sa Daisy UI klasama
-button elementu dodajemo dogadaj onClick
-u dogadaj onClick dodajemo anonimnu funkciju
-u anonimnu funkciju proslijedujemo funkciju setCount()
-dodajemo direktivu 'use client'

20. Fetch data
-u komponenti drinks/page.js, funkciji DrinksPage() dodajemo asinhronost
-kreiramo varijablu const url
-u funkciji DrinksPage() dodajemo metodu await fetch(url)
-vrijednost metode await fetch(url) pohranjujemo u varijablu const response
-dodajemo metodu await response.json()
-vrijednost metode await response.json() pohranjujemo u varijablu const data

21. Loading Component
-u komponenti drinks/page.js kreiramo funkciju fetchDrinks()
-u funkciju fetchDrinks() dodajemo metodu await new Promise() i varijable const response i const data
-dodajemo izjavu return data
-u funkciju DrinksPage() dodajemo funkciju await fetchDrinks()
-vrijednost funkcije await fetchDrinks() pohranjujemo u varijablu const drinks
-kreiramo loading.js fajl
-u loading.js fajlu kreiramo i eksportujemo funkciju loading() kao default

22. Error Component
-u folderu drinks kreiramo error.js fajl
-u error.js fajlu kreiramo i eksportujemo funkciju error() kao default
-u komponenti drinks/page.js, u funkciju fetchDrinks() dodajemo uslov if (!response.ok)

23. Nested Layouts
-u folderu drinks kreiramo layout.js fajl
-u layout.js fajlu kreiramo i eksportujemo funkciju DrinksLayout()
-funkciji DrinksLayout() dodajemo parametar destruktuirani prop children
-u jsx-u kreiramo HTML elemente sa Tailwind CSS klasama
-u roditelj div element dinamicki prikazujemo vrijednost prop children

24. Dynamic Routes
-u folderu drinks kreiramo folder [id] i komponentu page.js
-u [id]/page.js fajlu kreiramo i eksportujemo funkciju SingleDrinkPage() kao default
-funkciji SingleDrinkPage() dodajemo parametar destruktuirani prop params

25. Drinks List - Challenge
-u folderu components kreiramo komponentu DrinksList.jsx
-funkciji DrinksList() dodajemo parametar destruktuirani prop drinks
-u komponentu drinks/page.js importujemo komponentu DrinksList.jsx
-u jsx-u dodajemo komponentu DrinksList sa prop drinks
-u komponenti DrinksList.jsx, u jsx-u kreiramo ul element kao roditelj element sa Tailwind CSS klasama
-u ul element dodajemo metodu drinks.map()
-u funkciji map() kreiramo li element sa prop key
-importujemo komponentu Link
-u li element dodajemo komponentu Link sa prop href
-u prop href dodajemo dinamicki link

26. Single Drink - Challenge
-u komponenti [id]/page.js kreiramo varijablu const url
-importujemo komponentu Link
-kreiramo asinhronu funkciju getSingleDrink() sa parametrom id
-u funkciji getSingleDrink() kreiramo varijablu const res
-dodajemo uslov if (!res.ok)
-u uslov if dodajemo funkciju throw new Error()
-funkciji SingleDrinkPage() dodajemo asinhronost
-u funkciji SingleDrinkPage() kreiramo varijablu const data
-kreiramo varijable const title i const imgSrc
-u jsx-u, u roditelj div element dodajemo komponentu Link sa prop href i className

27. Static Images
-u komponentu [id]/page.js importujemo sliku drinkImg
-preuzmemo sliku
-kreiramo folder public
-preuzetu sliku pohranjujemo u folder public
-otvorimo link: https://nextjs.org/docs/pages/api-reference/components/image
-importujemo komponentu Image iz paketa Next Image
-u jsx-u dodajemo komponentu Image sa prop src, alt i className

28. Remote Images
-u komponenti [id]/page.js dodajemo komponentu Image sa prop src, alt, width, height, className i priority
-otvorimo link: https://stackoverflow.com/questions/76164057/next-js-hostname-not-configured-under-images-in-next-config-js-even-though-remot
-u next.config.mjs fajl dodajemo objekt images i niz remotePatterns

29. Responsive Images
-u komponentu DrinksList.jsx importujemo komponentu Image
-u jsx-u ul elementu dodajemo Tailwind CSS Grid klase
-u jsx-u, u komponenti Link kreiramo div element sa Tailwind CSS klasu
-u div element dodajemo komponentu Image
-komponenti Image dodajemo prop src, alt, className, sizes i fill

30. More Routing
-u folderu app kreiramo folder _css i styles.css fajl
-kreiramo foldere (dashboard), auth i komponentu page.js
-u folderu auth kreiramo folder [[...sign-in]] i komponentu route.js
-u pretrazivacu otvorimo rutu: http://localhost:3000/auth

31. Prisma Setup
-otvorimo web stranicu: https://www.prisma.io/
-otvorimo link: https://www.npmjs.com/package/prisma
-otvorimo link: https://www.npmjs.com/package/@prisma/client
-u terminalu instaliramo pakete Prisma i Prisma Client
-u terminalu ukucamo komande npm install prisma --save-dev i npm install @prisma/client
-u terminalu ukucamo komandu npx prisma init
-generisemo folder prisma i schema.prisma fajl
-u .gitignore fajl dodajemo .env fajl
-otvorimo link: https://www.prisma.io/docs/getting-started/quickstart-sqlite
-u .env fajl dodajemo u varijablu DATABASE_URL vrijednost "file:./dev.db"
-u schema.prisma fajl dodajemo u objekt datasource db key - value par  provider = "sqlite"
-otvorenim link: https://www.prisma.io/docs/guides/other/troubleshooting-orm/help-articles/nextjs-prisma-client-dev-practices#solution
-kreiramo folder utils i db.ts fajl
-u db.ts fajl kopiramo kod iz dokumentacije

32. Prisma Model
-u schema.prisma fajlu kreiramo model Task
-u terminalu ukucamo komandu npx prisma migrate dev 
-odaberemo ime task model
-generisemo folder migrations i fajlove unutar njega
-u terminalu ukucamo komandu npx prisma studio

33. Prisma CRUD
-otvorimo link: https://www.prisma.io/docs/concepts/components/prisma-client/crud
-u komponentu prisma-example importujemo instancu prisma iz foldera utils
-kreiramo asinhronu funkciju prismaHandlers()
-u funkciju prismaHandlers() dodajemo metodu await prisma.task.create()
-u funkciju create() dodajemo konfiguracioni objekt
-u konfiguracioni objekt dodajemo objekt data
-dodajemo metodu await prisma.task.findMany()
-vrijednost metode await prisma.task.findMany() pohranjujemo u varijablu const allTasks
-u funkciju createMany() dodajemo konfiguracioni objekt
-u konfiguracioni objekt dodajemo objekt orderBy
-u funkciju prismaHandlers() dodajemo metodu return allTasks
-funkciji PrismaExamplePage() dodajemo asinhronost
-u funkciju PrismaExamplePage() dodajemo funkciju await prismaHandlers()
-vrijednost funkcije await prismaHandlers() pohranjujemo u varijablu const tasks
-u jsx-u, u div element dodajemo metodu tasks?.map()
-u funkciji map() kreiramo h2 element sa prop key i className

34. Display Tasks - Challenge
-u folderu components kreiramo tri jsx komponente: TaskForm, TaskList i DeleteForm
-u komponentu tasks/page.js importujemo komponente TaskForm.jsx i TaskList.jsx
-u komponenti TaskList.jsx, funkciji TaskList() dodajemo asinhronost
-u funkciju TaskList() dodajemo metodu await.prisma.task.findMany()
-vrijednost metode await.prisma.task.findMany() pohranjujemo u varijablu const tasks
-u funkciju findMany() dodajemo konfiguracioni objekt
-u konfiguracioni objekt dodajemo objekt orderBy
-dodajemo uslov (tasks.length === 0) i h2 element sa Tailwind CSS klasama
-importujemo instancu prisma i komponentu Link
-u jsx-u kreiramo ul element
-u ul element dodajemo metodu tasks?.map()
-u funkciji map() kreiramo li element sa prop key i className
-u li elementu kreiramo element h2 i div
-h2 elementu dodajemo prop className i dinamicke klasu
-u div element dodajemo komponentu Link sa prop href i className
-importujemo komponentu DeleteForm.jsx
-u div element dodajemo komponentu DeleteForm sa prop id

35. Server Actions - Info

36. First Server Action
-u komponenti TaskForm.jsx, u jsx-u kreiramo form element kao roditelj element
-importujemo instancu prisma
-u form elementu kreiramo div element sa Tailwind CSS klasama
-u div elementu kreiramo elemente input i button sa Tailwind CSS klasama
-input elementu dodajemo prop type, className, placeholder, name i required
-button elementu dodajemo prop type i className
-funkciji TaskForm() dodajemo asinhronost
-kreiramo asinhronost funkciju createTask()
-form elementu dodajemo prop action
-u prop action proslijedujemo funkciju createTask
-funkciji createTask() dodajemo parametar formData
-u funkciju createTask dodajemo direktivu 'use server'
-dodajemo metodu formData.get()
-vrijednost metode formData.get() pohranjujemo u varijablu const content
-dodajemo metodu await prisma.task.create()
-u funkciju create() dodajemo konfiguracioni objekt
-u konfiguracioni objekt dodajemo objekt data
-importujemo funkciju revalidatePath iz paketa Next Cache
-otvorimo link: https://nextjs.org/docs/app/api-reference/functions/revalidatePath
-u funkciju createTask() dodajemo funkciju revalidatePath('/tasks')

37. Refactor App
-u folderu utils kreiramo actions.js fajl
-u actions.js fajl dodajemo direktivu 'use server'
-importujemo funkciju revalidatePath i instancu prisma
-u actions.js fajl premjestamo funkciju createTask()
-kreiramo asinhronu funkciju getAllTasks()
-u funkciju getAllTasks() dodajemo izjavu return prisma.task.findMany()
-u komponentu TaskList.jsx importujemo funkciju getAllTasks() iz actions.js fajla
-vrijednost funkcije await getAllTasks() pohranjujemo u varijablu const tasks
-u komponentu TaskForm.jsx importujemo funkcije createTask iz actions.js fajla

38. Delete Task
-u actions.js fajlu kreiramo i eksportujemo asinhronu funkciju deleteTask()
-funkciji deleteTask() dodajemo parametar formData
-u funkciji deleteTask() kreiramo varijablu const id
-dodajemo metodu await prisma.task.delete()
-dodajemo funkciju revalidatePath('/tasks')
-u komponentu DeleteForm.jsx importujemo funkciju deleteTask iz foldera utils
-u jsx-u kreiramo form element kao roditelj element
-funkciji DeleteForm() dodajemo parametar destruktuirani prop id
-form elementu dodajemo prop action
-u prop action proslijedujemo funkciju deleteTask
-u form elementu kreiramo input element sa prop type, name i value
-kreiramo button element sa prop className

39. Edit Task - Setup
-u actions.js fajlu kreiramo i eksportujemo asinhrone funkcije getTask() i editTask()
-funkciji getTask() dodajemo parametar id
-funkciji editTask() dodajemo parametar formData
-u folderu components kreiramo komponentu EditForm.jsx
-u folderu tasks kreiramo folder [id] i komponentu page.js
-u komponenti [id]/page.js kreiramo funkciju EditTaskPage()
-funkciji EditTaskPage() dodajemo parametar destruktuirani prop params
-funkciji EditTaskPage() dodajemo asinhronost
-importujemo funkciju getTask() iz foldera utils
-u funkciju EditTaskPage() dodajemo funkciju await getTask(params.id)
-vrijednost funkcije await getTask(params.id) pohranjujemo u varijablu const task
-u actions.js fajlu, u funkciju getTask() dodajemo metodu return prisma.task.findUnique()
-u funkciju findUnique() dodajemo konfiguracioni objekt
-u konfiguracioni objekt dodajemo objekt where
-u komponenti [id]/page.js, roditelj div elementu dodajemo prop className
-importujemo komponente Link i EditForm.jsx
-u roditelj div element dodajemo komponentu Link 
-komponenti Link dodajemo prop href i className
-ispod komponente Link dodajemo komponentu EditForm sa prop task

40. Edit Task - Complete
-u komponenti EditForm.jsx destruktuiramo varijable const { id, completed, content }
-dodajemo direktivu 'use client'
-u jsx-u kreiramo form element kao roditelj element
-form elementu dodajemo prop action i className
-importujemo funkciju editTask iz foldera utils
-u prop action proslijedujemo funkciju editTask
-u form elementu kreiramo input element sa prop type, name i value
-kreiramo jos jedan input element sa prop type, required, defaultValue, name i className
-kreiramo div element sa Daisy UI klasama
-u div elementu kreiramo elemente label, span i input
-input elementu dodajemo prop type, defaultChecked, id, name i className
-kreiramo button element sa Daisy UI klasama
-u actions.js fajlu kreiramo varijable const id, const content i const completed
-dodajemo metodu await prisma.task.update()
-u funkciju update() dodajemo konfiguracioni objekt
-u konfiguracioni objekt dodajemo objekte where i data
-otvorimo link: https://nextjs.org/docs/app/api-reference/functions/redirect
-importujemo funkciju redirect iz paketa Next Navigation
-u funkciju editTask() dodajemo funkciju redirect('/tasks')

41. Pending State
-otvorimo link: https://react.dev/reference/react-dom/hooks/useFormStatus
-u actions.js fajlu kreiramo i eksportujemo asinhronu funkciju createTaskCustom()
-u funkciju createTaskCustom() dodajemo metodu await new Promise()
-kreiramo komponentu TaskFormCustom.jsx
-u komponentu tasks/page.js importujemo komponentu TaskFormCustom.jsx
-u komponentu TaskFormCustom.jsx importujemo funkciju createTaskCustom iz foldera utils
-dodajemo direktivu 'use client'
-importujemo funkciju useFormStatus iz paketa React Dom
-kreiramo funkciju SubmitButton()
-u funkciju SubmitButton() dodajemo funkciju useFormStatus()
-vrijednost funkcije useFormStatus() pohranjujemo u destruktuiranu varijablu const { pending }
-u jsx-u premjestamo button elemente iz funkcije TaskFormCustom()
-button elementu dodajemo prop disabled
-u prop disabled proslijedujemo varijablu pending
-u button elementu dodajemo ternarni uslov za varijablu pending
-u funkciju TaskFormCustom() dodajemo komponentu SubmitButton

42. Error Checking
-u actions.js fajlu, u funkciju createTaskCustom() dodajemo blokove koda try - catch
-funkciji createTaskCustom() dodajemo parametar prevState
-u blok koda try dodajemo metodu awat prisma.task.create() i revalidatePath()
-dodajemo izjavu return objekt poruku
-u blok koda catch dodajemo izjavu return objekt poruku
-u komponentu TaskFormCustom.jsx importujemo funkciju useFormState iz paketa React Dom
-kreiramo varijablu const initialState
-u funkciji TaskFormCustom() dodajemo funkciju useFormState(createTaskCustom, initialState)
-vrijednost funkcije useFormState() pohranjujemo u varijable const [state, formAction]
-u prop action proslijedujemo funkciju formAction
-u form elementu dodajemo ternarni uslov state.message
-prvi dio ternarnog uslova je p element, a drugi dio ternarnog uslova je vrijednost null

43. Zod Library
-otvorimo web stranicu: https://zod.dev/
-otvorimo link: https://www.npmjs.com/package/zod
-u terminalu instaliramo paket Zod sa komandom npm i zod
-u actions.js fajlu importujemo instancu z iz paketa Zod
-u funkciji createTaskCustom() dodajemo metodu z.object()
-vrijednost metode z.object() pohranjujemo u varijablu const Task
-u blok koda try dodajemo metodu Task.parse()

44. Providers
-otvorimo link: https://www.npmjs.com/package/react-hot-toast
-u terminalu instaliramo paket React Hot Toast sa komandom npm i react-hot-toast
-u folderu app kreiramo providers.js fajl
-u providers.js fajlu kreiramo i eksportujemo funkciju Providers() kao default
-funkciji Providers() dodajemo parametar destruktuirani prop children
-dodajemo direktivu 'use client'
-importujemo komponentu Toaster iz paketa React Hot Toaster
-u jsx-u dodajemo prazan fragment kao roditelj element
-u komponentu layout.js importujemo komponentu Providers
-u main element dodajemo komponentu Providers sa otvorenim i zatvorenim tagom
-u komponentu TaskFormCustom.jsx importujemo funkcije useEffect i toast
-u funkciju TaskFormCustom() dodajemo funkciju useEffect()
-u funkciju useEffect() dodajemo dva uslova if

45. Delete Button - Challenge
-u komponentu DeleteForm.jsx dodajemo direktivu 'use client'
-importujemo funkciju useFormStatus iz paketa React Dom
-kreiramo funkciju SubmitButton()
-u funkciju SubmitButton() dodajemo funkciji useFormStatus()
-vrijednost funkcije useFormStatus() pohranjujemo u destruktuiranu varijablu const { pending }
-u jsx-u kreiramo button element sa Daisy UI klasama
-button elementu dodajemo prop disabled
-u prop disabled proslijedujemo vrijednost varijable pending
-u button element dodajemo ternarni operator za varijablu pending
-u funkciju DeleteForm() dodajemo komponentu SubmitButton 

46. Route Handlers - Info
-otvorimo link: https://nextjs.org/docs/app/building-your-application/routing/route-handlers
-otvorimo aplikaciju Postman

47. Route Handlers - GET
-u folderu app kreiramo foldere api, tasks i route.js fajl
-u tasks/route.js fajl importujemo instancu db iz foldera utils
-kreiramo i eksportujemo asinhronu funkciju GET() sa parametrom request
-u funkciju GET() dodajemo metodu await db.task.findMany()
-vrijednost metode await db.task.findMany() pohranjujemo u varijablu const tasks
-dodajemo izjavu return Response.json()
-u pretrazivacu otvorimo rutu: http://localhost:3000/api/tasks

48. Route Handlers - POST
-u posts/route.js fajlu kreiramo i eksportujemo asinhronu funkciju POST() sa parametrom request
-u funkciju POST() dodajemo metodu await request.json()
-vrijednost metode await request.json() pohranjujemo u varijablu const data
-dodajemo metodu await db.task.create()
-u funkciju createTask() dodajemo konfiguracioni objekt
-u konfiguracioni objekt dodajemo objekt data
-vrijednost metode await db.task.create() pohranjujemo u varijablu const task
-dodajemo izjavu Response.json()
-importujemo funkciju NextResponse iz paketa Next Server
-u funkcije GET() i POST() dodajemo funkciju NextResponse()

49. Middleware
-otvorimo link: https://nextjs.org/docs/app/building-your-application/routing/middleware
-kreiramo middleware.js fajl
-u middleware.js fajlu kreiramo i eksportujemo funkciju middleware()
-u funkciju middleware() dodajemo izjavu return Response.json()
-kreiramo i eksportujemo varijablu objekt const config
-u pretrazivacu otvorimo rutu: http://localhost:3000/about
-u objekt config dodajemo niz matcher
-importujemo funkciju NextResponse iz paketa Next Server
-u funkciju middleware() dodajemo izjavu return NextResponse()
-u pretrazivacu otvorimo rutu: http://localhost:3000/about

50. Render (optional)
-otvorimo web stranicu: https://render.com/
-otvorimo link: https://dashboard.render.com/new/database
-kreiramo PostgreSQL Projekt udemy-nextjs-openai
-u .env fajl dodajemo vrijednost varijable External Database URL sa web servisa Render
-kreiramo example.env fajl za primjer varijabli koje je potrebno kreirati
-u shcema.prisma fajlu, u objektu datasource db dodajemo opciju provider = "postgresql"
-u terminalu ukucamo komandu npx prisma db push

51. PlanetScale
-otvorimo web stranicu: https://planetscale.com/

52. Local Build
-u package.json fajl dodajemo u komandu "build": "npx prisma generate && next build"
-u komponenti prisma-example/page.js dodajemo uslov if (tasks.length === 0)
-obrisemo sve taskove koje smo imali
-u terminalu ukucamo komandu npm run build
-u terminalu ukucamo komandu npm start

53. Force Dynamic
-otvorimo link: https://nextjs.org/docs/app/api-reference/file-conventions/route-segment-config
-u folderu app/tasks kreiramo loading.js fajl
-u loading.js fajlu kreiramo i eksportujemo funkciju loading()
-u komponenti tasks/page.js kreiramo i eksportujemo varijablu const dynamic
-u terminalu ukucamo komandu npm run build
-u terminalu ukucamo komandu npm start

54. Deploy
-otvorimo web stranicu: https://vercel.com/
-na web stranici Vercel kreiramo novi projekt
-odaberemo opciju da kod importujemo sa Github repozitorija
-u projekt dodajemo varijablu iz .env fajla


Section 02: GPTGenius App

55. Important Info !!!

56. Intro

57. New App
-preuzmemo starter folder gptgenius

58. First Pages
-u folderu app kreiramo folder (dashboard)
-u folderu (dashboard) kreiramo komponentu layout.js
-u folderu (dashboard) kreiramo foldere chat, profile i tours
-u folderima chat, profile i tours kreiramo komponente page.js

59. Home Page
-u komponenti app/page.js, u jsx-u kreiramo HTML elemente sa DaisyUI klasama
-importujemo komponentu Link iz paketa Next Link

60. Important Update !!!

61. Clerk Setup
-otvorimo web stranicu: https://clerk.com
-kreiramo fajlove .env.local i .env.local.example
-u .env.local fajlu kreiramo env varijable NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY i CLERK_SECRET_KEY
-u .env.local.example fajl dodajemo primjer varijabli koje je potrebno kreirati
-otvorimo link: https://www.npmjs.com/package/@clerk/nextjs
-otvorimo link: https://clerk.com/docs/quickstarts/nextjs
-u terminalu instaliramo paket Clerk sa komandom npm i @clerk/nextjs@5
-u komponentu app/layout.js importujemo komponentu ClerkProvider iz paketa Clerk
-u jsx-u dodajemo komponentu ClerkProvider sa otvorenim i zatvorenim tagom
-kreiramo middleware.ts fajl
-u middleware.ts fajl importujemo funkciju authMiddleware iz paketa Clerk
-kreiramo i eksportujemo funkciju authMiddleware()
-kreiramo i eksportujemo varijablu objekt const config
-u pretrazivacu otvorimo rutu: http://localhost:3000/chat

62. Custom Auth Pages
-u folderu app kreiramo foldere sign-up, [[...sign-up]] i komponentu page.js
-u komponenti page.js kreiramo i eksportujemo funkciju SignUpPage()
-u komponentu page.js importujemo komponentu SignUp iz paketa Clerk
-u folderu app kreiramo foldere sign-in, [[...sign-in]] i komponentu page.js
-u komponenti page.js kreiramo i eksportujemo funkciju SignInPage()
-u komponentu page.js importujemo komponentu SignIn iz paketa Clerk
-u .env.local fajlu kreiramo nove cetiri env varijable
-u komponente page.js za kreiranje racuna i prijavu kreiramo div element sa Tailwind CSS klasama

63. React Icons
-otvorimo web stranicu: https://react-icons.github.io/react-icons/

64. Dashboard Layout
-otvorimo link: https://daisyui.com/components/drawer/
-u folderu components kreiramo komponentu Sidebar.jsx
-u komponentu (dashboard)/layout.js importujemo komponentu Sidebar.jsx
-u jsx-u kreiramo HTML elemente sa Daisy UI klasama

65. Sidebar
-u folderu components kreiramo tri jsx komponente SidebarHeader, NavLinks i MemberProfile
-u komponentu Sidebar.jsx importujemo kreirane komponente
-roditelj div elementu dodajemo Tailwind CSS klase

66. Sidebar Header
-u folderu components kreiramo komponentu ThemeToggle.jsx
-u komponenti ThemeToggle.jsx, u jsx-u kreiramo btn element sa DaisyUI klasama
-u komponentu SidebarHeader.jsx importujemo komponentu ThemeToggle.jsx
-importujemo React ikonicu SiOpenaigym
-u jsx-u roditelj div elementu dodajemo Tailwind CSS klase
-kreiramo h2 element sa Tailwind CSS klasama
-u div element dodajemo komponentu ThemeToggle

67. Nav Links
-u komponentu NavLinks.jsx importujemo komponentu Link iz paketa Next Link
-kreiramo niz links sa objekt rutama
-u jsx-u kreiramo ul element sa DaisyUI klasama
-u ul elementu dodajemo metodu links?.map()
-u funkciji map kreiramo li element sa prop key
-u element li dodajemo komponentu Link sa prop href i className

68. Member Profile
-otvorimo link: https://clerk.com/docs/components/user/user-button
-otvorimo link: https://clerk.com/docs/references/nextjs/current-user
-otvorimo link: https://clerk.com/docs/references/nextjs/auth
-u komponentu MemberProfile.jsx importujemo komponentu UserButton iz paketa Clerk Nextjs
-u jsx-u roditelj div elementu dodajemo Tailwind CSS klase
-u div element dodajemo komponentu UserButton sa prop afterSignOutUrl
-importujemo funkcije currentUser i auth iz paketa Clerk Nextjs Server
-funkciji MemberProfile() dodajemo asinhronost
-u funkciju MemberProfile() pozivamo funkcije await currentUser() i auth()
-vrijednost funkcije await currentUser() pohranjujemo u varijablu const user
-vrijednost funkcije auth() pohranjujemo u destruktuiranu varijablu const { userId }
-u div elementu kreiramo p element u kojem dinamicki prikazujemo korisnikovu e-mail adresu

69. Theme Toggle
-otvorimo link: https://daisyui.com/docs/themes/
-u tailwind.config.js fajl dodajemo objekt daisyui
-u komponentu app/layout.js, html elementu dodajemo atribut data-theme
-u komponentu ThemeToggle.jsx dodajemo direktivu 'use client'
-importujemo Ract ikonice BsMoonFill i BsSunFill iz paketa React Icons
-kreiramo varijablu objekt const themes
-u funkciji ThemeToggle() kreiramo state varijablu const theme i set funciju setTheme
-funkciji useState() dodajemo argument themes.winte useState(themes.winter)
-u jsx-u kreiramo button elementu sa prop onClick i className
-u button element dodajemo uslov ternarni operator theme === 'winter'
-prvi dio ternarnog operatora je ikonica BsMoonFill, a drugi dio ternarnog operatora je ikonica BsSunFill
-kreiramo funkciju toggleTheme
-u dogadaj onClick proslijedujemo funkciju toggleTheme
-u funkciji toggleTheme() kreiramo varijablu const newTheme
-dodajemo metodu document.documentElement.setAttribute()
-dodajemo funkciju setTheme(newTheme)

70. Boilerplate Overview

71. User Profile
-otvorimo link: https://stackoverflow.com/questions/78529760/nextjs-clerk-the-signin-component-is-not-configured-correctly
-u komponentu profile/page.js importujemo komponentu UserProfile iz paketa Clerk Nextjs
-u folderu profile kreiramo folder [[...rest]]
-u folder [[...rest]] premjestamo komponentu page.js iz foldera profile

72. React Hot Toast Library
-otvorimo web stranicu: https://react-hot-toast.com/
-otvorimo link: https://www.npmjs.com/package/react-hot-toast
-u terminalu instaliramo paket sa komandom npm i react-hot-toast
-u folderu app kreiramo komponentu providers.jsx
-u komponentu providers.jsx dodajemo direktivu 'use client'
-kreiramo i eksportujemo kao default funkciju Providers()
-funkciji Providers() dodajemo parametar destruktuirani prop children
-importujemo komponentu Toaster iz paketa React Hot Toast
-u jsx-u dodajemo prazan fragment kao roditelj element
-u prazan fragment dodajemo komponentu Toaster sa prop position
-ispod komponente Toaster dodajemo prop children
-u komponentu app/layout.js importujemo komponentu Providers
-u body element dodajemo komponentu Providers sa otvorenim u zatvorenim tagom
-u komponentu Providers dodajemo prop children
-u komponenti MemberProfile.jsx, komponenti UserButton dodajemo prop fallbackRedirectUrl umjesto prop afterSignOutUrl

73. Chat Structure
-u folderu components kreiramo komponentu Chat.jsx
-u komponentu chat/page.js importujemo komponentu Chat.jsx
-u komponentu Chat.jsx dodajemo direktivu 'use client'
-importujemo funkciju useState() iz paketa React
-kreiramo state varijable const text i const message
-kreiramo set funkcije setText i setMessage
-kreiramo funkciju handleSubmit() sa parametar e
-u funkciju handleSubmit() dodajemo metodu e.preventDefault()
-u jsx-u roditelj div elementu dodajemo Tailwind CSS klase
-u roditelj div elementu kreiramo div element i unutar njega h2 element
-u roditelj div elementu kreiramo form element sa prop onSubmit i className
-u form elementu kreiramo div element sa DaisyUI klasama
-u div elementu kreiramo elemente input i button sa DaisyUI klasama
-input elementu dodajemo prop type, placeholder, className, value, required i onChange
-button elementu dodajemo prop className i type
-form elementu dodajemo dogadaj onSubmit i prop className
-u dogadaj onSubmit proslijedujemo funkciju handleSubmit

74. React Query - Info
-otvorimo web stranicu: https://tanstack.com/query/v5/docs/framework/react/overview
-u terminalu instaliramo React Query pakete sa komandom npm i @tanstack/react-query @tanstack/react-query-devtools

75. React Query - Setup
-kreiramo fodler utils i actions.js fajl
-u actions.js fajlu kreiramo i eksportujemo asinhronu funkciju generateChatResponse() sa parametrom chatMessage
-importujemo funkciju useState iz paketa React
-u komponentu providers.jsx importujemo funkciju QueryClient, komponente QueryClientProvider i ReactQueryDevtools iz paketa Tanstack
-pozivamo funkciju useState() i unutar funkcije anonimnu funkciju
-u anonimnu funkciju dodajemo funkciju new QueryClient()
-vrijednost funkcije useState pohranjujemo u varijablu const [queryClient]
-u jsx-u dodajemo komponentu QueryClientProvider sa otvorenim i zatvorenim tagom 
-komponenti QueryClientProvider dodajemo prop client
-u prop client proslijedujemo vrijednost varijable queryClient
-u komponentu QueryClientProvider dodajemo komponentu ReactQueryDevtools
-u komponentu chat/page.js importujemo funkcije dehydrate, QueryClient i komponentu HydrationBoundary
-u jsx-u dodajemo komponentu HydrationBoundary kao roditelj element sa otvorenim i zatvorenim tagom
-komponenti HydrationBoundary dodajemo prop state
-u prop state proslijedujemo funkciju dehydrate(queryClient)
-u komponentu Chat importujemo funkcije useMutation i generateChatResponse iz paketa Tanstack
-u funkciji Chat() pozivamo funkciju useMutation()
-vrijednost funkcije useMutation() pohranjujemo u destruktuiranu varijablu const { mutate }
-u funkciju useMutation() dodajemo objekt i funkciju mutationFn
-u funkciju handleSubmit() dodajemo funkciju mutate(text) 

76. OpenAI - Pricing
-otvorimo web stranicu: https://openai.com/pricing

77. OpenAI - Playground
-otvorimo link: https://platform.openai.com/playground/chat?models=gpt-3.5-turbo

78. OpenAI - Docs
-otvorimo link: https://platform.openai.com/docs/overview